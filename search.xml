<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>浅谈最小生成树</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="最小生成树是什么？"><a href="#最小生成树是什么？" class="headerlink" title="最小生成树是什么？"></a>最小生成树是什么？</h2><p>通俗的说，在一个<strong>无向图</strong>里，要求选 $n - 1$ 条边，使得这 $n$ 个点<strong>连通</strong>，边权和最小的 $n - 1$ 条边就称为最小生成树。</p><span id="more"></span><h2 id="求解最小生成树的算法"><a href="#求解最小生成树的算法" class="headerlink" title="求解最小生成树的算法"></a>求解最小生成树的算法</h2><ol><li>$kruskal$，适用于稀疏图。</li><li>$prim$，适用于稠密图。</li></ol><p>在这里，我们只会讲到 $kruskal$ 算法，<del>因为 $prim$ 没有什么用！</del></p><h2 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="$kruskal$ 算法"></a>$kruskal$ 算法</h2><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p>$kruskal$ 算法是基于贪心的思想，再结合并查集判环而构成的。</p><p>思路：先把所有边存到数组里，然后按照边的大小从小到大排序。此时，我们只要一条一条边利用并查集慢慢合并，当就要有环的时候，再利用并查集判环就可以了。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>存边的数组不要开小，如果点数为 $n$，数组大小<strong>建议</strong>开到 $n^2$。</li><li>并查集数组不要忘记初始化。</li><li><strong>建议</strong>记录边的数量，到达 $n - 1$ 条边时及时跳出，不要浪费时间。</li></ol><h3 id="代码（带注释）"><a href="#代码（带注释）" class="headerlink" title="代码（带注释）"></a>代码（带注释）</h3><p>注：例题为 P3366。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, fa[<span class="number">5005</span>], sum, cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">&#125;a[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span>&#123;    <span class="comment">//按照权值排序</span></span><br><span class="line"><span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;     <span class="comment">//函数</span></span><br><span class="line"><span class="keyword">if</span>(fa[x] == x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i].u &gt;&gt; a[i].v &gt;&gt; a[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//初始化</span></span><br><span class="line">fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);   <span class="comment">//排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> e1 = a[i].u, e2 = a[i].v;</span><br><span class="line">e1 = <span class="built_in">find</span>(e1);      <span class="comment">//并查集找祖先</span></span><br><span class="line">e2 = <span class="built_in">find</span>(e2);</span><br><span class="line"><span class="keyword">if</span>(e1 != e2)&#123;</span><br><span class="line">sum += a[i].w;    <span class="comment">//权值和</span></span><br><span class="line">cnt++;      <span class="comment">//边数</span></span><br><span class="line">fa[e2] = e1;    <span class="comment">//合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt == n - <span class="number">1</span>)&#123;    <span class="comment">//如果已选 n - 1 条边</span></span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;orz&quot;</span>;    <span class="comment">//如果不连通</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>此算法最慢的部分在于排序，所以时间复杂度为 $O(mlog_2m)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 Trie 树</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88-Trie-%E6%A0%91/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88-Trie-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>Trie 树是一种能够<strong>高效</strong>的存储和使用字符串<strong>集合</strong>的一种东西。</p><span id="more"></span><h2 id="2-手动实现"><a href="#2-手动实现" class="headerlink" title="2. 手动实现"></a>2. 手动实现</h2><p>Trie 树究竟是什么东西呢？让我们通过存储一个字符串集合来直观的了解它。</p><p>已知我们要存储这样的字符串集合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br><span class="line">abfg</span><br><span class="line">aifff</span><br></pre></td></tr></table></figure><p>那么我们一个一个的来存储，第一个存储时，Trie 树是这样的：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ef0nurmj.png" alt=""></p><p>可以看出，Trie 树的存储实质上是建立在一棵树上，我们可以建立一个虚点为整棵树的根节点，然后再建立每个节点。然后建立第二个字符串：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tm9zekqt.png" alt=""></p><p>我们可以发现，<code>abfg</code> 的前面两个字符 <code>ab</code> 跟第一个字符串的和在一起了，这就是它省空间的秘诀：相同的字符可以和在一起。</p><p>然后再加入最后一个字符串，效果如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7dkuv4ds.png" alt=""></p><p>为了以后找字符串是否出现过，我们在字符串结尾的地方打上一个标记，一定要打：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6eapz6jd.png" alt=""></p><p>存储的原理就讲到这，接下来我们讲查询。</p><p>那个 $\color{red}{gou}$ 就有大用处了。</p><p>此时，假设我们查询的字符串为 <code>abfg</code>，我们要查询它是否存在。</p><p>此时我们的查询过程如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/dlqrjehg.png" alt=""></p><p>此时我们到最后<strong>一定</strong>要确定是否有标记，否则当一个查询字符串是现有字符串前缀的时候就会出错。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>这里给出的是一道题的模板，可以学习一下我的 Trie 树风格，别问我，我跟 $yxc$ 学的（$Acwing$ 的大老总）。</p><p>这里以 <a href="https://www.luogu.com.cn/problem/P2580">$\color{black}\texttt{P2580}$</a> 为例，讲一下模板代码。</p><p>插入部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">I</span><span class="params">(string s)</span></span>&#123;    <span class="comment">// s 表示向 Trie 树里插入的字符串</span></span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="type">int</span> u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!son[p][u])&#123;    <span class="comment">// 如果有儿子</span></span><br><span class="line">      son[p][u] = ++idx;    <span class="comment">// son 表示的是儿子节点编号</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = son[p][u];   <span class="comment">// 类似递归</span></span><br><span class="line">  &#125;</span><br><span class="line">  v[p] = <span class="literal">true</span>;     <span class="comment">//v 用来打标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Q</span><span class="params">(string s)</span></span>&#123;   <span class="comment">// 表示查询的字符串。</span></span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="type">int</span> u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!son[p][u])&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//如果没有孩子，直接退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = son[p][u];    <span class="comment">// 递归</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v[p];   <span class="comment">// 如果这个字符串有，返回 true，否则返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉很好打。</p><p>作者建议：深度理解代码后，打模板代码 $3$ 到 $5$ 遍，就基本可以掌握了。</p><h1 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h1><p>我们可以发现，在最坏的时候，我们要建立的节点数为所有字符串的长度之和，所以定义 $l$ 为所有字符串的长度之和，那么建立 Trie 树的时间复杂度是 $O(l)$ 的。</p><p>那么同样可以推出，在询问时，时间复杂度是查询的字符串长度（也可能比这个小）。</p><h1 id="例题推荐及讲解"><a href="#例题推荐及讲解" class="headerlink" title="例题推荐及讲解"></a>例题推荐及讲解</h1><p>在这里推荐一道很好的题目：<a href="luogu.com.cn/problem/P5149">$\color{black}\texttt{P5149}$</a>。</p><p>这道题的做法就是，用 Trie 树对排完位的座位进行标号，最后再去求逆序对数列就行了。</p><p>逆序对可以用两个东西求：</p><ol><li><p>树状数组。</p></li><li><p>归并排序。</p></li></ol><p>本博客就讲到这里，拜拜！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Trie 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈最短路</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="更新目录"><a href="#更新目录" class="headerlink" title="更新目录"></a>更新目录</h2><p>$\text{Update 2022.3.10}$，更新了负环的知识，并且新加了 $\text{Johnson}$ 算法。</p><h2 id="最短路简介"><a href="#最短路简介" class="headerlink" title="最短路简介"></a>最短路简介</h2><p>最短路定义：求出图中的最短路径。</p><span id="more"></span><h2 id="最短路种类"><a href="#最短路种类" class="headerlink" title="最短路种类"></a>最短路种类</h2><p>分为两种：</p><ol><li>单源最短路算法。</li><li>全源最短路算法。</li></ol><p>这里补充一点知识，源点的意思就是起点。</p><p>单源最短路算法，顾名思义，就是求出一个点到另外的所有点的最短路。而全源最短路算法就是求出任意两点之间的最短路。</p><h2 id="求最短路算法"><a href="#求最短路算法" class="headerlink" title="求最短路算法"></a>求最短路算法</h2><p>同样分为两种：</p><p>单源最短路算法：</p><ol><li>$\text{Dijkstra}$。</li><li>$\text{Bellman-ford}$。</li><li>$\text{SPFA}$。</li></ol><p>多源最短路算法：</p><ol><li>$\text{Floyd}$。</li><li>$\text{Johnson}$</li></ol><p>这里只是列出一点时间复杂度优秀且<strong>比较</strong>常用的一点算法，比如像 $\text{dfs}$ 这样的就没有加进来。</p><p>那么，来看看它们是怎么工作的（单源最短路时把 $1$ 看作源点）。</p><h3 id="text-1-Dijkstra"><a href="#text-1-Dijkstra" class="headerlink" title="$\text{1. Dijkstra}$"></a>$\text{1. Dijkstra}$</h3><p>$\text{Dijkstra}$ 的工作原理如下：</p><ol><li><p>将所有点分为白点和黑点，其中白点表示最短路还没有被确定，黑点表示已经确定了。</p></li><li><p>将 $1$ 点标为黑点。</p></li><li><p>把当前最短路最短的黑点连出去的边都松弛，并且都变为黑点。</p></li><li><p>黑点就不需要松弛了。</p></li></ol><p>最后说一下，当边权都是正数或者负数地情况下才能使用该算法，因为两边之和大于第三边。</p><p>所以代码就很容易写了（P3371）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s, dis[<span class="number">100005</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[<span class="number">100005</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[<span class="number">10000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">edges[tot].to = v;</span><br><span class="line">edges[tot].w = w;</span><br><span class="line">edges[tot].next = head[u];</span><br><span class="line">head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//为什么这里要循环 n，因为要把 n 个点全部变为黑点</span></span><br><span class="line"><span class="type">int</span> mini = <span class="number">1e9</span>, p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; mini)&#123;</span><br><span class="line">mini = dis[j];</span><br><span class="line">p = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = head[p]; j; j = edges[j].next)&#123;</span><br><span class="line"><span class="type">int</span> nxt = edges[j].to;</span><br><span class="line"><span class="keyword">if</span>(dis[p] + edges[j].w &lt; dis[nxt])&#123;</span><br><span class="line">dis[nxt] = dis[p] + edges[j].w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[p] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dijkstra</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我们发现这里算法的复杂度是 $O(N^2)$ 的，非常的慢，所以考虑优化。</p><p>我们发现，每次都要求最小值，太麻烦了，而每次恰好又只修改最小的那个点的颜色，所以我们想到了什么，$\text{priority_queue}$ 啊，利用它来动态维护最小值就可以了，所以时间成功降到 $O(m\log n)$。</p><p>代码如下（P4779）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">edges[tot].to = v;</span><br><span class="line">edges[tot].w = w;</span><br><span class="line">edges[tot].next = head[u];</span><br><span class="line">head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[s], s));</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">top</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[x])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[x] + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">dis[edges[i].to] = dis[x] + edges[i].w;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[edges[i].to], edges[i].to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dijkstra</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意这里要利用 $\text{pair}$ 来维护两个元素，并且还要从小到大排序，所以要取负。</p><h2 id="text-2-Bellman-ford"><a href="#text-2-Bellman-ford" class="headerlink" title="$\text{2. Bellman-ford}$"></a>$\text{2. Bellman-ford}$</h2><p>与其说 $\text{Dijkstra}$ 是一种以点为核心的算法，那么 $\text{Bellman-ford}$ 就是一种以边为核心的算法。</p><p>首先我们想，一条最短路最多只有 $n - 1$ 条边（不考虑负权环），所以每条边最多也就被松弛 $n - 1$ 次，所以 $\text{Bellman-ford}$ 的大体模型就出来了。</p><p>所以代码就出来了（P3371）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u[N], v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i]= <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[u[j]] + w[j] &lt; dis[v[j]])&#123;</span><br><span class="line">dis[v[j]] = dis[u[j]] + w[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bellman_ford</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cout &lt;&lt; (dis[i] == <span class="number">1e9</span> ? <span class="number">2147483647</span> : dis[i]) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>那么它的时间复杂度就是 $O(nm)$，当 $m = n^2$ 时，时间复杂度则是 $O(n^3)$。</p><h2 id="text-3-SPFA"><a href="#text-3-SPFA" class="headerlink" title="$\text{3. SPFA}$"></a>$\text{3. SPFA}$</h2><p>首先声明一点：<del>这是一种已经死了的算法。</del></p><p>$\text{SPFA}$ 是在 $\text{Bellman-ford}$ 的基础之上进行了队列优化。</p><p>我们想，$\text{Bellman-ford}$ 有时候会松弛一点无用的边，那么我们是否可以只松弛有用的边呢？</p><p>答案是肯定的。我们在松弛第一条边时，把点存进队列里，然后把连出去的边继续松弛。</p><p>所以时间复杂度就优化了一点点。</p><p>代码如下（P3371）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">edges[tot].to = v;</span><br><span class="line">edges[tot].w = w;</span><br><span class="line">edges[tot].next = head[u];</span><br><span class="line">head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line">vis[s] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[x] + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">dis[edges[i].to] = dis[x] + edges[i].w;</span><br><span class="line"><span class="keyword">if</span>(!vis[edges[i].to])&#123;</span><br><span class="line">q.<span class="built_in">push</span>(edges[i].to);</span><br><span class="line">vis[edges[i].to] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SPFA</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以时间复杂度就为 $O(km)$，$k$ 是一个很小的常数。</p><p>但是，但是，但是，$\text{SPFA}$ 在最坏情况下仍然可以退化成 $O(nm)$，各种优化的 $\text{hack}$ 请看：<a href="https://www.luogu.com.cn/paste/35b2sh8c">https://www.luogu.com.cn/paste/35b2sh8c</a>。</p><h2 id="附-text-SPFA-判负环"><a href="#附-text-SPFA-判负环" class="headerlink" title="附 - $\text{SPFA}$ 判负环"></a>附 - $\text{SPFA}$ 判负环</h2><p>负环的定义：一个环上的的边权和为负数的环，既可以是有向图，也可以是无向图。</p><p>负环的判定：</p><ol><li><p>从点的角度判断，一个点最多被其余的 $n - 1$ 个点松弛，因此统计每个点的松弛次数，若存在点 $x$ 被松弛 $n - 1$ 次以上，则必然存在负环。</p></li><li><p>从边的角度判断，一条最短路最多包含 $n - 1$ 条边，因此统计起点到点 $x$ 的边数，若存在点 $x$ 到起点的边数在 $n - 1$ 以上，则必然存在负环。</p></li></ol><p>注意事项：</p><ol><li>应用 $\text{SPFA}$ 实现，而不是 $\text{dijkstra}$，因为有负边权。</li><li>如果使用第一种方法，应统计的应该是点 $x$ 被多少<strong>不同的点</strong>松弛。</li></ol><p>第一种方法代码实现（P3385）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line"><span class="type">int</span> dis[N], in[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">  tot++;</span><br><span class="line">  edges[tot].to = v;</span><br><span class="line">  edges[tot].w = w;</span><br><span class="line">  edges[tot].next = head[u];</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    dis[i] = <span class="number">1e9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line">      <span class="keyword">if</span>(dis[x] + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">        dis[edges[i].to] = dis[x] + edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(!vis[edges[i].to])&#123;</span><br><span class="line">          q.<span class="built_in">push</span>(edges[i].to);</span><br><span class="line">          vis[edges[i].to] = <span class="literal">true</span>;</span><br><span class="line">          in[edges[i].to]++;</span><br><span class="line">          <span class="keyword">if</span>(in[edges[i].to] &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in">sizeof</span>(in));</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">      <span class="type">int</span> u, v, w;</span><br><span class="line">      cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">      <span class="keyword">if</span>(w &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, w);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">SPFA</span>() ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法代码实现（题目一样的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> dis[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">edges[tot].to = v;</span><br><span class="line">edges[tot].w = w;</span><br><span class="line">edges[tot].next = head[u];</span><br><span class="line">head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">vis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[x] + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">dis[edges[i].to] = dis[x] + edges[i].w;</span><br><span class="line">cnt[edges[i].to] = cnt[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt[edges[i].to] &gt;= n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!vis[edges[i].to])&#123;</span><br><span class="line">q.<span class="built_in">push</span>(edges[i].to);</span><br><span class="line">vis[edges[i].to] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">tot = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="keyword">if</span>(w &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line"><span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (<span class="built_in">spfa</span>() ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对比时间复杂度，第二种方法的速度快一点。</p><h2 id="text-4-Floyd"><a href="#text-4-Floyd" class="headerlink" title="$\text{4. Floyd}$"></a>$\text{4. Floyd}$</h2><p>$\text{Floyd}$ 是一种基于中转点松弛思想的最短路算法。</p><p>思路：</p><p>枚举一个点 $k$，表示一个中转点，再枚举两个点 $i, j$，此时我们可以松弛当 $i$ 到 $j$ 的最短路必须经过 $k$ 时能否更短。</p><p>代码就非常好写了（核心代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i][k] + dis[k][j] &lt; dis[i][j])&#123;</span><br><span class="line">            dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就不给出完整代码了。</p><h2 id="text-5-Johnson"><a href="#text-5-Johnson" class="headerlink" title="$\text{5. Johnson}$"></a>$\text{5. Johnson}$</h2><p>这是一种能够将负边权转化成正边权从而可以使用 $\text{dijkstra}$ 解决问题的算法。</p><p>步骤：</p><ol><li><p>创建一个虚点 $0$，从 $0$ 向每个点连一条边权为 $0$ 的边。</p></li><li><p>跑一遍 $\text{SPFA}$，求出 $0$ 到每个点的最短路 $h_i$。</p></li><li><p>最关键的一步来了，把 $e_{i, j}$ 这条边加上 $h_i - h_j$。</p></li><li><p>再跑 $n$ 遍 $\text{dijkstra}$。</p></li><li><p>把最短路 $d_{i, j}$ 加上 $-h_i + h_j$。</p></li><li><p>然后就完事了。</p></li></ol><p>这里以模板题为例给出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> dis[N], d[<span class="number">3005</span>][<span class="number">3005</span>];</span><br><span class="line"><span class="type">int</span> in[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">  tot++;</span><br><span class="line">  edges[tot].to = v;</span><br><span class="line">  edges[tot].w = w;</span><br><span class="line">  edges[tot].next = head[u];</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">h[i] = <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line">h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(h[x] + edges[i].w &lt; h[edges[i].to])&#123;</span><br><span class="line">h[edges[i].to] = h[x] + edges[i].w;</span><br><span class="line"><span class="keyword">if</span>(!vis[edges[i].to])&#123;</span><br><span class="line">  in[edges[i].to]++;</span><br><span class="line">  <span class="keyword">if</span>(in[edges[i].to] &gt; n)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">q.<span class="built_in">push</span>(edges[i].to);</span><br><span class="line">vis[edges[i].to] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[s], s));</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">top</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[x])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[x] + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">dis[edges[i].to] = dis[x] + edges[i].w;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[edges[i].to], edges[i].to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">SPFA</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = head[i]; j; j = edges[j].next)&#123;</span><br><span class="line">      edges[j].w = edges[j].w + h[i] - h[edges[j].to];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="built_in">dijkstra</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(dis[j] != <span class="number">1e9</span>)&#123;</span><br><span class="line">        d[i][j] = dis[j] - h[i] + h[j];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        d[i][j] = <span class="number">1e9</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">      sum += ((<span class="type">long</span> <span class="type">long</span>)j * (<span class="type">long</span> <span class="type">long</span>)d[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是看起来很长，其实有些题目卡 $\text{SPFA}$，并且<strong>有时候</strong>题目也不会刻意卡你 $\text{Bellman-ford}$，所以你可以用 $\text{Bellman-ford}$ 求 $h_i$。</p><h2 id="参与人员"><a href="#参与人员" class="headerlink" title="参与人员"></a>参与人员</h2><p>大力感谢 @<a href="https://www.luogu.com.cn/user/123216">apple365</a> 对本文的贡献与支持。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈单调栈 &amp; 单调队列</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88%E5%8D%95%E8%B0%83%E6%A0%88-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88%E5%8D%95%E8%B0%83%E6%A0%88-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>需要掌握用 $\text{STL}$ 和手写的方式来实现栈与队列。</p><p>因为作者的代码风格会变换。</p><h2 id="何为单调栈（队列）"><a href="#何为单调栈（队列）" class="headerlink" title="何为单调栈（队列）"></a>何为单调栈（队列）</h2><p>指的是当栈（队列）里的元素有单调性时的栈（队列）。</p><span id="more"></span><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>可能你会觉得单调栈很难理解，其实只要动手画画图就可以了。</p><p>我们手动画一个图（以 P5788 为例）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/u2tylmdw.png" alt=""></p><p>那么我们循环到第一个元素时，由于栈里面没有比他小的数，所以直接弹入：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6m5pbbm4.png" alt=""></p><p>此时我们栈里的元素是一个结构体 $\text{Node}$，第一个数表示元素大小，第二个表示位置。</p><p>那么我们再循环到第二个数，由于栈里没有比它要小的数所以此时我们弹出 $a_1$，并将 $a_1$ 的答案值改为 $2$（因为是记录位置）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/szb6m3da.png" alt=""></p><p>此时我们循环到 $a_3$ 了发现比栈里的元素都要小，直接弹入：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nhg36cxn.png" alt=""></p><p>那么，现在循环到 $a_4$，我们发现 $a_4 &gt; a_3$ 所以将 $a_3$ 弹出，并将 $a_3$ 的答案值设为 $4$：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vnkd8x83.png" alt=""></p><p>到了最后一个元素 $a_5$ 了，此时我们发现 $a_5 &gt; a_4$ 并且 $a_5 &gt; a_2$，所以把 $a_4$ 和 $a_2$ 弹出且将答案都修改为 $5$：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hprd75fj.png" alt=""></p><p>此时我们发现我们的答案序列是 $2\ 5\ 4\ 5\ 0$，也就是对的。</p><p>我们发现，在单调栈中的元素在任意时刻都是满足单调递减的，从而实现查找最近的元素。</p><p>随后我们来分析时间复杂度：由于每个元素只会出队和入队各一次，所以时间复杂度为 $O(2n)$，也就是 $O(n)$ 的。可以看出单调栈的时间复杂度十分优秀。</p><p>P5788 的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], d[N];</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk1, stk2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stk1.<span class="built_in">empty</span>() &amp;&amp; a[i] &gt; stk1.<span class="built_in">top</span>())&#123;</span><br><span class="line">      d[stk2.<span class="built_in">top</span>()] = i;</span><br><span class="line">      stk1.<span class="built_in">pop</span>();</span><br><span class="line">      stk2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stk1.<span class="built_in">push</span>(a[i]);</span><br><span class="line">    stk2.<span class="built_in">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有什么问题可以私信 _Alexande_。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈分块</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88%E5%88%86%E5%9D%97/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88%E5%88%86%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本博客的 $\sqrt{n}$ 全部定义为向下取整。</p><h2 id="分块是什么？"><a href="#分块是什么？" class="headerlink" title="分块是什么？"></a>分块是什么？</h2><p>分块是一种优雅的暴力。</p><span id="more"></span><h2 id="分块的思想"><a href="#分块的思想" class="headerlink" title="分块的思想"></a>分块的思想</h2><p>分块，就是把长度为 $n$ 的数列分成几个块（这里我们定义分成 $\sqrt{n}$ 个块），然后对于每个块分段解决，其<strong>普通</strong>时间复杂度（在块长为 $\sqrt{n}$ 的情况下）为 $m \sqrt{n}$，$m$ 为<strong>区间</strong>操作的个数。</p><p>首先我们要理解分块是如何分的，我们首先造一组样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 4 2 8 4 6 2 9 7 3</span><br></pre></td></tr></table></figure><p>那么如果分成 $\sqrt{n}$ 个块的情况下，应该是这样分的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 2 | 8 4 6 | 2 9 7 3</span><br></pre></td></tr></table></figure><p>由于我们要严格保证有 $\sqrt{n}$ 个块，所以可能在最后会有一段不足 $\sqrt{n}$ 的数（就比如说 $3$），所以我们把这段数接在最后面。</p><p>我们定义 $L_i$ 为第 $i$ 个块的最左端，$R_i$ 为第 $i$ 个块的最右端，则 $L_i$ 为 $(i - 1) \times \sqrt{n} + 1$，$R_i$ 为 $i \times \sqrt{n}$。</p><p>那么我们还要维护一个数组 $pos_i$，表示下标 $i$ 所在的块。我们只需要枚举每个块的左端点和右端点，直接赋值即可。</p><p>下面是分块的初始化代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] = (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] = i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">pos[j] = i;</span><br><span class="line"><span class="comment">//     </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的初始化是基本操作，是分块之前必须做的预处理，接下来我们看如何操作。</p><p>由于 hzwer 大佬的数列分块入门九题对分块造成了非常大的影响，所以这里就用这九道题来讲（这九道题可以在 LOJ 上自己找）。</p><h2 id="数列分块入门-1"><a href="#数列分块入门-1" class="headerlink" title="数列分块入门 $1$"></a>数列分块入门 $1$</h2><p>我们还是分 $\sqrt{n}$ 个块，在修改时，我们维护一个数组 $tag$，表示加法的标记，然后对于加的整块（完整的块）直接加 $tag$ 即可，而对于两端不完整的块（也就是修改左端点 $lt$ 和修改右端点 $rt$ 的所在块）直接暴力加即可。</p><p>对于查询，只需输出 $tag_{pos_i} + a_i$ 即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L[N], R[N], pos[N];</span><br><span class="line"><span class="type">int</span> tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">tag[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] = (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] = i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">pos[j] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> op, l, r, c;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">update</span>(l, r, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; a[r] + tag[pos[r]] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="数列分块入门-2"><a href="#数列分块入门-2" class="headerlink" title="数列分块入门 $2$"></a>数列分块入门 $2$</h2><p>这道题的难点就在于查询小于 $c$ 的数，首先我们可以对于每一个块，用一个 $vector$ 数组来存，然后对于每个块的 $vector$ 排个序，所以，在查询时，我们就可以直接对于每个块使用 $lower_bound$ 来求了。</p><p>而对于修改，由于散块的大小顺序可能会被改变，所以重新排一遍序就可以了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num[N];</span><br><span class="line"><span class="type">int</span> L[N], R[N], pos[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resort</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">num[x].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[x]; i &lt;= R[x]; i++)&#123;</span><br><span class="line">num[x].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(num[x].<span class="built_in">begin</span>(), num[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">tag[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[x] &lt; val)&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[x] &lt; val)&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">ans += <span class="built_in">lower_bound</span>(num[i].<span class="built_in">begin</span>(), num[i].<span class="built_in">end</span>(), val - tag[i]) - num[i].<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[y] &lt; val)&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] += (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] += i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">pos[j] = i;</span><br><span class="line">num[i].<span class="built_in">push_back</span>(a[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(num[i].<span class="built_in">begin</span>(), num[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> op, l, r, c;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">update</span>(l, r, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(l, r, c * c) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数列分块入门-3"><a href="#数列分块入门-3" class="headerlink" title="数列分块入门 $3$"></a>数列分块入门 $3$</h2><p>这道题在 $2$ 的基础上改一点即可，因为我们知道了小于 $c$ 的个数，所以在整块内小于 $c$ 最大的值就是 $a_i$ 加上块所在的 $tag$，此时只要判断有没有小于 $c$ 的数就可以了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num[N];</span><br><span class="line"><span class="type">int</span> L[N], R[N], pos[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resort</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">num[x].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[x]; i &lt;= R[x]; i++)&#123;</span><br><span class="line">num[x].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(num[x].<span class="built_in">begin</span>(), num[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">tag[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[x] &lt; val)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, a[i] + tag[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[x] &lt; val)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, a[i] + tag[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(val - tag[i] &lt;= num[i][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, num[i][<span class="built_in">lower_bound</span>(num[i].<span class="built_in">begin</span>(), num[i].<span class="built_in">end</span>(), val - tag[i]) - num[i].<span class="built_in">begin</span>() - <span class="number">1</span>] + tag[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[y] &lt; val)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, a[i] + tag[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] += (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] += i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">pos[j] = i;</span><br><span class="line">num[i].<span class="built_in">push_back</span>(a[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(num[i].<span class="built_in">begin</span>(), num[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> op, l, r, c;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">update</span>(l, r, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(l, r, c) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数列分块入门-4"><a href="#数列分块入门-4" class="headerlink" title="数列分块入门 $4$"></a>数列分块入门 $4$</h2><p>在 $1$ 的基础上增加了区间查询，直接注意在计算每个块时加上 $tag$ 即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos[N], L[N], R[N], sum[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line">sum[x] += (rt - lt + <span class="number">1</span>) * val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line">sum[x] += (R[x] - lt + <span class="number">1</span>) * val;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">tag[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line">sum[y] += (rt - L[y] + <span class="number">1</span>) * val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">ans += tag[x];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">ans %= mod;</span><br><span class="line">ans += tag[x];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">ans %= mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">ans += sum[i];</span><br><span class="line">ans %= mod;</span><br><span class="line">ans += (R[i] - L[i] + <span class="number">1</span>) % mod * tag[i] % mod;</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">ans %= mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">ans %= mod;</span><br><span class="line">ans += tag[y];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] = (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] = i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">sum[i] += a[j];</span><br><span class="line">pos[j] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line">cin &gt;&gt; op;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> x, y, k;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"><span class="built_in">update</span>(x, y, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> x, y, k;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(x, y, k + <span class="number">1</span>) % (k + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数列分块入门-5"><a href="#数列分块入门-5" class="headerlink" title="数列分块入门 $5$"></a>数列分块入门 $5$</h2><p>由于开方操作很不好计算，所以我们可以从另一个角度取想。</p><p>我们想，当一个块里的数全部都是 $\le 1$ 时，我们就没有必要算下去了，由于开方最多开 $4$ 次才变成 $1$，所以时间复杂度显然没有问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos[N], L[N], R[N], sum[N];</span><br><span class="line"><span class="type">bool</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">sum[x] -= a[i];</span><br><span class="line">a[i] = <span class="built_in">sqrt</span>(a[i]);</span><br><span class="line">sum[x] += a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">sum[x] -= a[i];</span><br><span class="line">a[i] = <span class="built_in">sqrt</span>(a[i]);</span><br><span class="line">sum[x] += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">f[i] = <span class="literal">true</span>;</span><br><span class="line">sum[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">a[j] = <span class="built_in">sqrt</span>(a[j]);</span><br><span class="line">sum[i] += a[j];</span><br><span class="line"><span class="keyword">if</span>(a[j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">f[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">sum[y] -= a[i];</span><br><span class="line">a[i] = <span class="built_in">sqrt</span>(a[i]);</span><br><span class="line">sum[y] += a[i]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">ans += sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] = (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] = i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">pos[j] = i;</span><br><span class="line">sum[i] += a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> op, l, r, c;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">update</span>(l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(l, r) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 ST 表</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88-ST-%E8%A1%A8/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88-ST-%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="text-ST-表是什么"><a href="#text-ST-表是什么" class="headerlink" title="$\text{ST}$ 表是什么"></a>$\text{ST}$ 表是什么</h2><p>$\text{ST}$ 表是解决 RMQ（区间最值问题）的一种可靠工具。</p><p>它能够维护静态区间最值，并且时间复杂度是 $O(n\log n)$，常数极小，<del>相比线段树，不知道好到哪里去了。</del></p><span id="more"></span><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>$\text{ST}$ 表利用倍增的思想来求区间最值。</p><p>首先我们可以令 $f_{i, j}$ 表示从位置 $i$ 开始的后面一共 $2^j$ 个数的最大值，注意，这 $2^j$ 个数包括 $i$。</p><p>所以我们可以得出以下初始结论：$f_{i, 0}$。</p><p>那么我们就可以轻而易举的推出 $f<em>{i, j}$ 是由哪两个区间推出来的了。首先我们知道：$2^j = 2^{j - 1} \times 2^{j - 1}$，那么当前区间长为 $2^j$ 的区间就应该为两个长度为 $2^{j - 1}$ 的区间取 $\max$ 的来。这样思考，那么 $f</em>{i, j} = \max(f<em>{i, j - 1}, f</em>{i + 2^{j - 1}, j - 1})$。此时的 $i + 2^{j - 1}$ 就是第二个长度为 $2^{j - 1}$ 的区间的起始点。</p><p>这样来看，$ST$ 表的 $f$ 数组更类似与 $dp$ 的转移，而我们的 $j$ 是递减的，所以我们应该在第一层循环枚举 $j$，那么循环的边界就肯定是 $\log n$ 的。然后我们看对于 $i$ 的循环，对于 $i$ 的循环，应该有两个条件：</p><ol><li><p>$i \le n$。</p></li><li><p>$j + 2^j - 1 \le n$。</p></li></ol><p>这个式子我们是可以轻而易举的推出来的。但是，作者想说的是，虽然式子推出来了，但是式子里有许多 $2^j$ 和 $\log j$，所以我们可以用一个数组存下来，<del>卡常数</del>。</p><p>接下来是预处理代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">logg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">  bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">  logg[i] = logg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= logg[n]; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; j + bin[i] - <span class="number">1</span> &lt;= n; j++)&#123;</span><br><span class="line">    f[j][i] = <span class="built_in">max</span>(f[j][i - <span class="number">1</span>], f[j + bin[i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并没有放上初始化 $f_{i, 0}$ 的代码。</p><p>然后我们如何查询呢？首先我们要知道一点：对于长度为 $x$ 的区间，设 $k = \log(x)$，则这段区间肯定可以被两端长度为 $2^k$ 的区间覆盖起来。</p><p>知道了这个结论，就很简单了吧！接下来直接放代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">21</span>], logg[N], bin[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">      f = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    x = x * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span>();</span><br><span class="line">  m = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    f[i][<span class="number">0</span>] = <span class="built_in">read</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  logg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">    bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    logg[i] = logg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= logg[n]; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; j + bin[i] - <span class="number">1</span> &lt;= n; j++)&#123;</span><br><span class="line">      f[j][i] = <span class="built_in">max</span>(f[j][i - <span class="number">1</span>], f[j + bin[i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    x = <span class="built_in">read</span>();</span><br><span class="line">    y = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> len = y - x + <span class="number">1</span>, tmp = logg[len];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[x][tmp], f[y - bin[tmp] + <span class="number">1</span>][tmp]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> ST 表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈树链剖分</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="树链剖分是什么？"><a href="#树链剖分是什么？" class="headerlink" title="树链剖分是什么？"></a>树链剖分是什么？</h2><p>树链剖分，简称树剖，是一种<del>卡常小技巧</del>，可以解决树上差分和 LCA 揉搓在一起的问题。</p><span id="more"></span><h2 id="树链剖分的思想"><a href="#树链剖分的思想" class="headerlink" title="树链剖分的思想"></a>树链剖分的思想</h2><p>我们需要接触以下名词：</p><ul><li><p>重儿子：指一个节点的所有儿子中所在子树节点最多的那个儿子。</p></li><li><p>轻儿子：指除重儿子外其余的节点。</p></li><li><p>重边：指任意两个重儿子相连的边（注意，只是一条边）。</p></li><li><p>轻边：指除重边外其余的边。</p></li><li><p>重链：指一条全是由重边组成的路径，其顶部是轻儿子。</p></li></ul><p>我从 NaCly_Fish 大佬的博客下搬了一张图片：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/45367.png" alt=""></p><p>从这里，我们可以清晰的看出，哪些边是哪些属性（画红色的边是重边）。</p><p>由于需要预处理出这些信息并且后面查询时需要在重链上面跳，所以我们需要一些信息（这里默认 $1$ 节点是根节点）：</p><ul><li><p>$dep_i$，指 $i$ 节点的深度。</p></li><li><p>$size_i$，指 $i$ 节点所在的子树大小。</p></li><li><p>$son_i$，指 $i$ 节点的重儿子。</p></li><li><p>$fa_i$，指 $i$ 节点的父亲。</p></li><li><p>$top_i$，指 $i$ 节点所在的重链顶点（为什么需要这个呢？因为我们查询的时候需要跳重链！）</p></li><li><p>$id_i$，指 $i$ 节点的 $\text{dfs}$ 序。</p></li></ul><p>然后我们分批进行预处理，为什么呢？因为有些信息是要通过某些信息才能得来的！</p><p>第一次预处理 $\text{dfs1}$，我们求出前四个信息（这应该难不倒你！）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  fa[x] = f;</span><br><span class="line">  size[x] = <span class="number">1</span>;</span><br><span class="line">  dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> maxi = <span class="number">-1e9</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(edges[i].to != f)&#123;</span><br><span class="line">      <span class="built_in">dfs1</span>(edges[i].to, x);</span><br><span class="line">      size[x] += size[edges[i].to];</span><br><span class="line">      <span class="keyword">if</span>(size[edges[i].to] &gt; maxi)&#123;</span><br><span class="line">        maxi = size[edges[i].to];</span><br><span class="line">        son[x] = edges[i].to;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了第二次预处理时，我们需要维护一个线段树，以 $id$ 为下标插入，到了后面会说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">  top[x] = t;</span><br><span class="line">  id[x] = ++sum;</span><br><span class="line">  <span class="keyword">if</span>(a[x])&#123;   <span class="comment">//这里是个优化，如果是 0 就不要加了</span></span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x], a[x]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!son[x])&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[x], t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(edges[i].to != son[x] &amp;&amp; edges[i].to != fa[x])&#123;</span><br><span class="line">      <span class="built_in">dfs2</span>(edges[i].to, edges[i].to);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，一颗子树内的所有 $id$ 都是连续的，一条重链上的 $id$ 也是连续的。</p><p>所以加整条重链就就可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]);</span><br></pre></td></tr></table></figure><p>此时我们就可以这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fa[top[x]];</span><br></pre></td></tr></table></figure><p>这样就直接跳到重链的头了。</p><p>所以我们不断这样跳，第一个操作就完成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  val %= p;</span><br><span class="line">  <span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])&#123;</span><br><span class="line">      <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], val);</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个操作也是一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])&#123;</span><br><span class="line">      <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]);</span><br><span class="line">    ans %= p;</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y]);</span><br><span class="line">  <span class="keyword">return</span> ans % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 $3, 4$ 个操作都是针对于子树的，又由于子树的 $id$ 是连续的，所以我们可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  val %= p;</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x] + size[x] - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x] + size[x] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>然后你就学会了树链剖分。</del> 至于线段树，baidu 是个好东西。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到 _Alexande_ 的博客</title>
      <link href="/2022/06/11/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0-Alexande-%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/06/11/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0-Alexande-%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="关于本人"><a href="#关于本人" class="headerlink" title="关于本人"></a>关于本人</h2><ul><li><p>本人是口胡选手。</p></li><li><p>本人目前是 xxs。</p></li><li><p>本人目前还在摸鱼，没有搞 whk。</p></li></ul><h2 id="关于-blog"><a href="#关于-blog" class="headerlink" title="关于 blog"></a>关于 blog</h2><p>首先，本 blog 是置顶 blog，所以前面会有 “[置顶]”，前面带有 “[算法]”的 blog 仅指<strong>本人的学习笔记，并没有算法和数据结构之分。</strong></p><p>还有就是，你可以在最后看见一些奇怪的东西，如果你不知道怎么用，可以尝试按下 F12，打开 “Console”，然后 Ctrl + v 再按 Enter。</p><p>如果你希望在 blog 中寻找一些东西，你可以按下 F3 并输入你想搜索的东西。</p><p>然后，如果你发现有些东西写错了，可以私信 _Alexande_。</p><p>最后，希望你快乐的阅读本蒟蒻的 blog。</p><h2 id="关于以上"><a href="#关于以上" class="headerlink" title="关于以上"></a>关于以上</h2><p>以上介绍为洛谷搬运而来，所以有些许不准确！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈树状数组</title>
      <link href="/2022/06/10/%E6%B5%85%E8%B0%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2022/06/10/%E6%B5%85%E8%B0%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li><p>了解二进制以及性质。</p></li><li><p>了解计算机中的原码，反码，补码。</p></li></ol><p>这些是学会树状数组的必备功，如果不会可以上网搜一下（<del>反正不会耽误你多少时间</del>）。</p><span id="more"></span><h2 id="树状数组是什么？"><a href="#树状数组是什么？" class="headerlink" title="树状数组是什么？"></a>树状数组是什么？</h2><ul><li><p>树状数组是一种可以高效（相比于线段树常数小一点）解决单点查询，区间修改或者单点修改，区间查询。</p></li><li><p>树状数组是一种利用二进制拆分思想的高级数据结构</p></li></ul><p>以上是它的简介。</p><h2 id="树状数组的思想"><a href="#树状数组的思想" class="headerlink" title="树状数组的思想"></a>树状数组的思想</h2><p>树状数组（Binary Indexed Tree），是一种数据结构，我们还是通过一个题目来了解它：P3374。</p><p>我们又来想暴力啦！</p><ol><li><p>暴力，时间复杂度 $O(N^2)$。</p></li><li><p>前缀和，时间复杂度 $O(N^2)$。</p></li><li><p><del>线段树，可以过但代码太长。</del></p></li></ol><p>现在假设你不会写线段树，那么我们就需要树状数组这种数据结构。</p><p><strong>注意，下面的部分建议读者反复观看。</strong></p><p>树状数组的主要思想就是二进制拆分，我们来看看是怎么个拆法。</p><p>首先假设我们的序列为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">1 0 2 1 2 3 0 3 0 5 3 2 1</span><br></pre></td></tr></table></figure><p>首先我们将 $13$，也就是所谓的 $n$ 进行转二进制，得 $1101$，我们发现这个二进制数里有三个 $1$，也就是说 $13 = 2^3 + 2^2 + 2^0$，这里利用倍增得思想，从大到小排，听不懂也没关系。</p><p>所以我们可以将整个序列 $13$ 个数分成以下几个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">1 0 2 1 2 3 0 3 | 0 5 3 2 | 1</span><br></pre></td></tr></table></figure><p>| 为分隔符，所以我们发现每个部分得长度对应这这些二进制 $1$ 的数值，由于一个数的二进制拆分是唯一的，所以这些部分也都是唯一的。我们可以用 $tree$ 数组来存放每个部分的数值和，现在我们规定以下 $tree$ 的存储方式：</p><p>$tree<em>8$ 为第一部分的数值和，$tree</em>{12}$ 为第二部分的数值和，$tree_{13}$ 为第三部分的数值和。</p><p>为什么这么定义呢？我们可以发现，$8$ 正好就是 $2^3$，$12$ 正好就是 $2^3 + 2^2$，而 $13$ 又正好就是 $2^3 + 2^2 + 2^0$。我们发现，每个部分记录数值和的 $tree$ 下标都是不断以 $1$ 的数值叠加的。</p><h3 id="最初的最初（-text-lowbit-）"><a href="#最初的最初（-text-lowbit-）" class="headerlink" title="最初的最初（$\text{lowbit}$）"></a>最初的最初（$\text{lowbit}$）</h3><p>我们该怎样计算这些 $tree$ 的下标呢？这里我们就需要用到函数 $\text{lowbit}$，意思是最低位。它表示的是一个数的二进制数的最低位的 $1$ 以及跟后面的 $0$ 所组成的数。就比如说 $13$ 的二进制数 $1101$ 的 $\text{lowbit}$ 就是二进制数 $1$，也就是十进制数 $1$。</p><p>那么我们发现，第三个部分 $tree$ 的下标是 $13$，也就是 $n$，而第二个部分 $tree$ 的下标就是 $13 - \text{lowbit(13)}$，也就是 $12$，继续下去，第一个部分 $tree$ 的下标就是 $12 - \text{lowbit(12)}$，也就是 $8$!</p><p>实际上，这样的事情并不是巧合，而是从 $tree$ 的下标的本身规律来定义的 $\text{lowbit}$。</p><p>现在我们考虑 $\text{lowbit}$ 如何计算，难道就真的要二进制拆分吗？其实不需要，我们发现，一个数的二进制与这个二进制数的取反加 $1$ 相互进行 $\&amp;$ 操作就正好是这个数的 $\text{lowbit}$！具体原因可以上网搜，又由于这个二进制数的取反加 $1$ 正是这个数的补码（$x$ 的补码等于 $-x$），所以 $\text{lowbit}(x) = x \&amp; -x$！</p><h3 id="关于一些关系问题"><a href="#关于一些关系问题" class="headerlink" title="关于一些关系问题"></a>关于一些关系问题</h3><p>比如说要查询 $1$ ~ $13$，那么最初加上 $tree_{13}$ 之后又要加上什么呢？我们应该是要加上 $tree_8$，如果你仔细思考的话，就知道 $8 = 13 - \text{lowbit}(13)$，那么这个部分的后面那个部分的下标就是 $x + \text{lowbit}(x)$，前面部分的下标就是 $x - \text{lowbit}(x)$。</p><h3 id="更新（-text-update-）"><a href="#更新（-text-update-）" class="headerlink" title="更新（$\text{update}$）"></a>更新（$\text{update}$）</h3><p>由于更改一个点只会讲后面部分的节点前缀和给更改，所以应该是不断 $ + \text{lowbit}(x)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">tree[x] += val;</span><br><span class="line">x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询（-text-query-）"><a href="#查询（-text-query-）" class="headerlink" title="查询（$\text{query}$）"></a>查询（$\text{query}$）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">sum += tree[x];</span><br><span class="line">x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">sum += tree[x];</span><br><span class="line">x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">tree[x] += val;</span><br><span class="line">x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">update</span>(i, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line">cin &gt;&gt; op;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> x, k;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line"><span class="built_in">update</span>(x, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组可以解决什么问题？"><a href="#树状数组可以解决什么问题？" class="headerlink" title="树状数组可以解决什么问题？"></a>树状数组可以解决什么问题？</h2><p>树状数组擅长解决这两类问题：</p><ol><li><p>逆序对。</p></li><li><p>二维偏序。</p></li></ol><h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>这里有两种方法。</p><h4 id="1-离散化"><a href="#1-离散化" class="headerlink" title="1. 离散化"></a>1. 离散化</h4><p>我们可以讲以权值建树状数组，然后将值进行 $+ 1$ 操作，然后直接前缀和一下就可以了</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> p;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">    d[i] += c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">    sum += d[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x.x == y.x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.p &lt; y.p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i].x;</span><br><span class="line">    a[i].p = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    vis[a[i].p] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="built_in">update</span>(vis[i], <span class="number">1</span>);</span><br><span class="line">    ans += (i - <span class="built_in">query</span>(vis[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该很简单。</p><h4 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h4><p>首先我们按照下标建树状数组，然后我们把 $a$ 排序（升序），每次查询前缀和，然后将本身 $ + 1$ 就行了。</p><p><del>代码没有</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈线段树</title>
      <link href="/2022/06/08/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2022/06/08/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li>了解位运算（为线段树优化做铺垫）。</li><li>了解堆。</li><li>了解树。</li></ol><p>如果您还没有学完，就可以不用看下面的内容了。</p><span id="more"></span><h2 id="线段树是什么？"><a href="#线段树是什么？" class="headerlink" title="线段树是什么？"></a>线段树是什么？</h2><ul><li><p>线段树是一种可以解决区间问题的利器。</p></li><li><p>线段树是一种高级数据结构。</p></li><li><p>线段树是一种<strong>二叉搜索树</strong>（来源于网上）。</p></li></ul><p>只不过以上这些都是介绍，其实真正的线段树并没有那么恐怖。</p><h2 id="线段树的思想"><a href="#线段树的思想" class="headerlink" title="线段树的思想"></a>线段树的思想</h2><p>线段树（segment tree），又名区间树。我们可以通过一个题目来直观的了解它：P3372。</p><p>我们按照常规思路想：</p><ol><li><p>暴力，时间复杂度 $O(N^2)$。</p></li><li><p>前缀和，由于有修改操作，所以时间复杂度为 $O(N^2)$。</p></li></ol><p>这个复杂度是我们不可接受的，所以我们用线段树来解决这个问题。</p><p>我们假设原来的序列为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 9 3 1 2 5 2 2</span><br></pre></td></tr></table></figure><p>线段树，顾名思义，首先要建一棵<strong>二叉</strong>树：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8cut34o7.png" alt=""></p><p>一定要注意是二叉树。</p><p>这棵树按照堆式存储来编号，一共有 $15$ 个节点。</p><p>然后我们赋予它每个节点一点值，并且把值记录为 $tree$：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9wqpjw8f.png" alt=""></p><p>每个节点旁边的一个区间代表这个节点的值是这个区间的和，例如 $tree_5 = 4$。</p><p>那么区间又有什么特殊的性质呢？假设一个节点所代表的区间是 $[l, r]$，那么它的两个子节点的区间就分别是 $[l, (l + r &gt;&gt; 1)]$，$[(l + r &gt;&gt; 1), r]$。就是分治的思想。</p><p>线段树的意义就讲完了，接下来将如何实现。</p><h3 id="最初的最初（-text-pushup-）"><a href="#最初的最初（-text-pushup-）" class="headerlink" title="最初的最初（$\text{pushup}$）"></a>最初的最初（$\text{pushup}$）</h3><p>$\text{pushup}$ 是一个函数，表示向上更新的意思，每次可以更新节点 $cur$ 的值。</p><p>$\text{pushup}$ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[cur] = tree[cur &lt;&lt; <span class="number">1</span>] + tree[(cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>];   <span class="comment">//更新</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是一个回溯操作。</p><h3 id="建树（-text-build-）"><a href="#建树（-text-build-）" class="headerlink" title="建树（$\text{build}$）"></a>建树（$\text{build}$）</h3><p>这里非常简单，就是不断的分治/递归下去，最后再用 $\text{pushup}$ 更新就可以了。</p><p>注意，到了叶子节点可以直接返回值。</p><p>$\text{build}$ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt)</span> <span class="comment">//cur 为树上节点，管辖 [lt, rt] 的数列区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lt == rt)   <span class="comment">//递归到叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[cur] = a[lt];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid);   <span class="comment">//继续分治/递归</span></span><br><span class="line">    <span class="built_in">build</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">    <span class="built_in">pushup</span>(cur);  <span class="comment">//向上传递结果</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里时间复杂度为 $O(4N)$。</p><h3 id="查询（-text-query-）"><a href="#查询（-text-query-）" class="headerlink" title="查询（$\text{query}$）"></a>查询（$\text{query}$）</h3><p>举个例子。</p><p>就比如说查询区间 $[3, 8]$，我们首先把问题看到节点 $1$。节点 $1$ 说我管得范围太大了，得让我的两个儿子来解决。然后节点 $2$ 说，我也解决不了，又得给我的两个儿子解决。节点 $4$ 说这事跟我没关系，但节点 $5$ 说我正好就是问题中的一部分，可以解决。再来看节点 $3$，它说我也可以正好解决。所以询问的结果就是 $tree_5 + tree_3$。</p><p>从上述讲话中来看，其实就是不断的传儿子，只要在区间内就返回。</p><p>画图表示一下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/84vih07k.png" alt=""></p><p>所以查询操作到的每个区间就只有三种选择：</p><ol><li>询问的区间 $[x, y]$ 和这个节点所覆盖的区间 $[lt, rt]$ 根本没有关系。</li></ol><p>图示如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8243u4xu.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qva96nkw.png" alt=""></p><ol><li>询问的区间 $[x, y]$ 和这个节点所覆盖的区间 $[lt, rt]$ 是完全包含的关系。</li></ol><p>图示如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/oy58z9in.png" alt=""></p><ol><li>问的区间 $[x, y]$ 和这个节点所覆盖的区间 $[lt, rt]$ 是部分包含的关系。</li></ol><p>图示如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8exetcrs.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xqsftoji.png" alt=""></p><p>此时我们只有当区间是 $3$ 的情形时才下传。</p><p>所以我们的代码就可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">//cur 代表当前的节点，lt, rt 表示这个节点所管辖的区间，x, y 表示我要询问的区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; rt || y &lt; lt) <span class="comment">//都已经没有关系了，直接返回 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y) <span class="comment">//是 [x, y] 的一部分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;   <span class="comment">//向左右儿子请求答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid, x, y) + <span class="built_in">query</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里时间复杂度是 $O(\log_2N)$ 的。</p><h3 id="更新（-text-update-）"><a href="#更新（-text-update-）" class="headerlink" title="更新（$\text{update}$）"></a>更新（$\text{update}$）</h3><p>再来举个例子，更新 $[3, 8]$。</p><p>我们不断地下传给儿子，直到到了叶子节点之后，然后再向上更新。</p><p>这个思路应该很好理解，就是把所有点所在的叶子节点都改完后，再上传更新。</p><p>画图表示一下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/j1ipwby8.png" alt=""></p><p>然后我们更新又分为三点：</p><ol><li>更新区间 $[x, y]$ 与这个节点管辖的区间 $[lt, rt]$ 没有关系。</li></ol><p>这里的图示与查询一样。</p><ol><li>更新区间 $[x, y]$ 与这个节点管辖的区间 $[lt, rt]$ 是完全包含且 $lt = rt$。</li></ol><p><del>这里作者不画，请自行脑补（bushi）。</del></p><p>其实就是到达了叶子节点。</p><ol><li>更新区间 $[x, y]$ 与这个节点管辖的区间 $[lt, rt]$ 是部分包含关系。或者是完全包含但是 $lt ≠ rt$。</li></ol><p>这里的图示也与查询一样。</p><p>然后只有当情况 $3$ 发生才传递给左右孩子。</p><p>$\text{update}$ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span> <span class="comment">//在 [x, y] 的区间元素均加 val</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; rt || y &lt; rt) <span class="comment">// 没有任何关系</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lt == rt &amp;&amp; x &lt;= lt &amp;&amp; rt &lt;= y) <span class="comment">//是叶子节点，且落在 [x, y] 内</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[cur] += val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">update</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">    <span class="built_in">update</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">    <span class="built_in">pushup</span>(cur); <span class="comment">//cur 的左右孩子有可能修改了，那么 cur 管辖的区间和要更新</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的时间复杂度为 $O(4N)$。</p><h3 id="优化-1-（-text-lazy-tag-）"><a href="#优化-1-（-text-lazy-tag-）" class="headerlink" title="优化 $1$（$\text{lazy-tag}$）"></a>优化 $1$（$\text{lazy-tag}$）</h3><p>我们发现，虽然建树和查询的时间复杂度是<del>很低</del>的，但是更新的时间复杂度很高，连暴力都比不上。</p><p>我们思考更新的时间高的原因，是因为你把每个元素都给更新了，而如果后面又没有查询这段区间，那岂不是就亏了。</p><p>所以，总结一段话：<strong>修改是为询问而服务的。</strong></p><p>所以就诞生了 $\text{lazy-tag}$ 这个东西（没错，就是懒~标记）。</p><p>我们可以记录一个数组 $tag$，来记录每个节点的懒标记数值。所以，只要还没有查询到，这个懒标记就一直在睡觉~~（bushi）。</p><p>又来举上面那个例子，更新区间 $[3, 8]$，此时，我们发现节点 $5$ 和节点 $3$ 是被完全包含的，所以我们就把更新的值放在节点 $5$ 和节点 $3$ 上面，先把自己的值给加了（注意，一定要先把自己的值先加上），然后再把 $\text{lazy-tag}$ 加上要更新的值，等到以后有机会再还给儿子节点。</p><p>那么给出打懒标记的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span> <span class="comment">//cur，[lt, rt] 元素加 val</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[cur] += val;  <span class="comment">//加上以后要还给儿子们每个多少值</span></span><br><span class="line">    tree[cur] += (rt - lt + <span class="number">1</span>) * val;   <span class="comment">//这里要给自己加上</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有人就问了，你这个懒标记总不能放在这里不动呀！那查询或更新的时候怎么办？没错，懒标记在这个时候的勤快了，在查询或更新的途中就顺便还“债”，把差的值还给儿子节点，同时又在儿子节点上打上标记，然后循环往复。</p><p>所以懒标记核心就一句话：只要你不查询，我就在这里睡觉，只要你一查询，我就托你顺便带给儿子节点。</p><p>然后给出下放标记（俗称托人带物，有个专业名词叫 $\text{pushdown}$）函数代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt)</span> <span class="comment">//lt, rt 表示 cur 节点所管辖的区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tag[cur] == <span class="number">0</span>) <span class="comment">//这里很重要，当没有标记，也就是为 0 时，就不要向下传了（有的题目不加会错）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">addtag</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid, tag[cur]); <span class="comment">//给左右孩子打标记</span></span><br><span class="line">    <span class="built_in">addtag</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt, tag[cur]);</span><br><span class="line">    tag[cur] = <span class="number">0</span>;   <span class="comment">//最后还掉一身的债</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的 $\text{query}$ 和 $\text{update}$ 都要改一下：</p><p>$\text{query}$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">//cur 代表当前的节点，lt, rt 表示这个节点所管辖的区间，x, y 表示我要询问的区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; rt || y &lt; lt) <span class="comment">//都已经没有关系了，直接返回 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y) <span class="comment">//是 [x, y] 的一部分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(cur, lt, rt); <span class="comment">//在这里下放标记，位置一定不能错</span></span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;   <span class="comment">//向左右儿子请求答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid, x, y) + <span class="built_in">query</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\text{update}$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span> <span class="comment">//在 [x, y] 的区间元素均加 val</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; rt || y &lt; rt) <span class="comment">// 没有任何关系</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y) <span class="comment">//是被完全包含，打懒标记</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">addtag</span>(cur, lt, rt, val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(cur, lt, rt);   <span class="comment">//只要向下递归就要 pushdown</span></span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">update</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">    <span class="built_in">update</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">    <span class="built_in">pushup</span>(cur); <span class="comment">//cur 的左右孩子有可能修改了，那么 cur 管辖的区间和要更新</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先为什么 $\text{query}$ 和 $\text{update}$ 的 $\text{pushdown}$ 要放在那个位置，因为无论你时询问还是更新，只要向下递归就会下传。</p><p>至于 $\text{update}$ 的，当然是要在完全包含时才能 $\text{addtag}$ 的啦！</p><p>使用 $\text{lazy-tag}$ 之后时间复杂度会降到 $O(\log_2N)$（原理和查询一样）。</p><h3 id="优化-2-（标记永久化）"><a href="#优化-2-（标记永久化）" class="headerlink" title="优化 $2$（标记永久化）"></a>优化 $2$（标记永久化）</h3><p>线段树最出名的就是 $\text{lazy-tag}$ 了，它的优秀时间复杂度和实用性可以应对大多数情况。</p><p>而标记永久化呢？就是应对那些小部分情况。比如主席树区间修改，树套树（这里指线段树相套）矩阵修改。</p><p>标记永久化和 $\text{lazy-tag}$ 的区别：</p><ol><li><p>拒绝下传标记。</p></li><li><p>不一定每个区间的 $tree$ 加上 $tag$ 都是相对正确的。</p></li></ol><p>那么我们如何不用标记下传呢？</p><ol><li>我们的标记的值要加上 $tag \times (rt - lt + 1)$，并且要上传标记所带来的值。</li></ol><p>所以我们的 $\text{pushup}$ 就要改造一番：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  tree[node] = tree[node &lt;&lt; <span class="number">1</span>] + tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + (rt - lt + <span class="number">1</span>) * tag[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是在左右儿子的基础上加上这个节点的标记所给它带来的影响。</p><p>那么我们的 $\text{update}$ 也要改造一番：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y &lt; lt || x &gt; rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    tag[node] += val;   <span class="comment">//标记 += val，并且拒绝下传，直接 return ;</span></span><br><span class="line">    tree[node] += (rt - lt + <span class="number">1</span>) * val;   <span class="comment">//这个节点要加上值</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">  <span class="built_in">pushup</span>(node, lt, rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对于查询，我们只需要在一路时来加上相应的区间长度乘上<strong>这个区间的</strong> $tag$ 就可以了，利用一顿数学乱搞，就可以证明这样是对的（建议自己手推）。最后就是注意由于完全包含的已经加了，所以就不用再加一遍了。</li></ol><p>这里可以自己动手画画图，就可以明白了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y &lt; lt || x &gt; rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[node];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">min</span>(rt, y) - <span class="built_in">max</span>(lt, x) + <span class="number">1</span>) * tag[node] + <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y) + <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记永久化其实在现实中用得不多，出题人也不会去出这些稀奇古怪得题目（<del>除非是出题人脑袋有病，诚心卡你</del>），所以这一章节也没有什么用啦！</p><h3 id="最后的最后（空间提醒-amp-时间复杂度说明）"><a href="#最后的最后（空间提醒-amp-时间复杂度说明）" class="headerlink" title="最后的最后（空间提醒 &amp; 时间复杂度说明）"></a>最后的最后（空间提醒 &amp; 时间复杂度说明）</h3><p>这里先说一下，$tree$ 和 $tag$ 都要开 $4N$ 这么大。</p><p>证明：</p><p>一棵完全二叉树的节点数量为 $2N - 1$（这个可以自己 baidu），又因为线段树可能不是完全二叉树，可能多出 $2N - 1$ 个叶子节点，所以一共就是 $4N - 2$，差不多就是 $4N$。</p><p>所以最初的建树与更新都是 $O(4N)$ 的复杂度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这里给出 线段树 $1$ 的所有代码（<del>相信没有人会看吧</del>）。</p><p>代码 $1$（$\text{lazy-tag}$）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long    <span class="comment">//只提醒这里，要开 long long</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N * <span class="number">4</span>], tag[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">  tree[node] = tree[node &lt;&lt; <span class="number">1</span>] + tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  tag[node] += val;</span><br><span class="line">  tree[node] += (rt - lt + <span class="number">1</span>) * val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!tag[node])&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">addtag</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, tag[node]);</span><br><span class="line">  <span class="built_in">addtag</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, tag[node]);</span><br><span class="line">  tag[node] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">    tree[node] = a[lt];</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">  <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; rt || y &lt; lt)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    <span class="built_in">addtag</span>(node, lt, rt, val);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(node, lt, rt);</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">  <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; rt || y &lt; lt)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[node];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(node, lt, rt);</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y) + <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">int</span> x, y, k;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">int</span> x, y;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码 $2$（标记永久化）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N * <span class="number">4</span>], tag[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  tree[node] = tree[node &lt;&lt; <span class="number">1</span>] + tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + (rt - lt + <span class="number">1</span>) * tag[node];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">    tree[node] = a[lt];</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">  <span class="built_in">pushup</span>(node, lt, rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y &lt; lt || x &gt; rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    tag[node] += val;</span><br><span class="line">    tree[node] += (rt - lt + <span class="number">1</span>) * val;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">  <span class="built_in">pushup</span>(node, lt, rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y &lt; lt || x &gt; rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[node];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">min</span>(rt, y) - <span class="built_in">max</span>(lt, x) + <span class="number">1</span>) * tag[node] + <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y) + <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">int</span> x, y, k;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">int</span> x, y;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>应该讲得很清楚（过于自信）。</del></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>使用线段树还可以解决区间最大值，最小值，最大公约数等问题。使用线段树解决的问题必须满足<strong>区间加法</strong>（这是重点）。</p><p>所谓区间加法。设 $[l, r]$，并且 $mid$ 是中点（$l + r &gt;&gt; 1$），打个比方：</p><p>$[l, mid]$ 的和 $+$ $[mid + 1, r]$ 的和等于 $[l, r]$ 的和。</p><p>区间加法就是这个意思。</p><h2 id="可持久化线段树-主席树"><a href="#可持久化线段树-主席树" class="headerlink" title="可持久化线段树/主席树"></a>可持久化线段树/主席树</h2><p><del>听说主席树这个名字是 OIer 们在谈论政治的时候发明了这个玩意。</del></p><h2 id="可持久化线段树有什么用"><a href="#可持久化线段树有什么用" class="headerlink" title="可持久化线段树有什么用"></a>可持久化线段树有什么用</h2><p>可持久化线段树可以保存每一个历史版本的线段树，使得可以在每一个历史版本上做查询和修改。</p><p>简单来说，就是可以后悔。</p><h2 id="可持久化线段树的思想"><a href="#可持久化线段树的思想" class="headerlink" title="可持久化线段树的思想"></a>可持久化线段树的思想</h2><p>我们还是通过一个例题来了解它：P3919。</p><p>我们可以发现什么？</p><p>我们可以发现这些东西：</p><ol><li><p>每次只有<strong>单点赋值</strong>。</p></li><li><p>每次只有单点查询。</p></li><li><p>涉及到每个历史版本的保存。</p></li></ol><p>那么，如何保存每个历史版本呢？</p><p>如果针对每一次操作开一棵线段树的话，空间会炸！</p><p>那么我们想，由于整棵树是一棵二叉树，所以高度为 $\log_2N$ 左右，所以我们每次单点赋值只会更改最多 $\log_2N$ 左右的线段树节点！这句话就是主席树的关键。</p><p>所以针对每一次操作，我们只需保存新的被修改过的线段树节点就行了。</p><p>那么我们如何建这棵线段树呢？请看以下这个图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o6mkrwr3.png" alt=""></p><p>我们可以看出，更新操作在原始版本上是不做任何修改的。我们只需要新建要修改的节点的副本，并且把副本的值一一改变，再与原始版本连边就可以了。</p><p>新建副本的意思就是，新建修改过后的节点，然后连边到要修改的历史版本的线段树里的没有修改过的节点（自己看图就清晰了）。</p><p>那么我们需要注意什么：</p><ol><li><p>主席树里有很多个版本，因此就会有很多的根节点，我们可以用数组 $root$ 来保存每个版本的根节点。</p></li><li><p>每个节点有很多个父亲，但是永远只有<strong>两个儿子</strong>。</p></li><li><p>由于编号的问题，所以我们必须要记录节点个数以此来进行编号。</p></li><li><p>注意主席树里新建的点的左右儿子。</p></li><li><p>由于是单点修改，所以不需要懒标记。</p></li><li><p>在新建节点时，我们只需要把左右儿子分辨清楚就行了。</p></li></ol><p>现在我们发现从任何一个根节点向下递归都是一棵线段树。</p><p>所以按照这个思路就可以开始打代码了。</p><p>这里我是把初始看成版本 $1$。</p><p>这里因为 $\text{pushup}$ 还是一样的操作，所以我就没有放上来了。</p><h3 id="建树（-text-build-）-1"><a href="#建树（-text-build-）-1" class="headerlink" title="建树（$\text{build}$）"></a>建树（$\text{build}$）</h3><p>我们建树的时候可以先定义结构体 $segment_tree$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;     <span class="comment">//代表左右孩子</span></span><br><span class="line">    <span class="type">int</span> lt, rt;    <span class="comment">//代表所表示的区间</span></span><br><span class="line">    <span class="type">int</span> val;      <span class="comment">//代表节点的值</span></span><br><span class="line">&#125;tree[N * <span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>然后跟普通线段树一样的操作，只不过把 $root_1 = 1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">      tree[node].lt = lt, tree[node].rt = rt;</span><br><span class="line">      tree[node].v = a[lt];   <span class="comment">//这里由于是叶子节点所以左右儿子不用记</span></span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tot = <span class="built_in">max</span>(tot, node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);   <span class="comment">//这里的 tot 表示的是节点总个数</span></span><br><span class="line">    tree[node].lt = lt, tree[node].rt = rt;</span><br><span class="line">    tree[node].l = node &lt;&lt; <span class="number">1</span>, tree[node].r = node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;    <span class="comment">//记录一下信息</span></span><br><span class="line">    <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">    <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">    <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很简单。</p><h3 id="更新（-text-update-）-1"><a href="#更新（-text-update-）-1" class="headerlink" title="更新（$\text{update}$）"></a>更新（$\text{update}$）</h3><p>这里的更新先把代码放上来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[node].l &amp;&amp; !tree[node].r)&#123;</span><br><span class="line">        tot++;</span><br><span class="line">        tree[tot].lt = tree[node].lt, tree[tot].rt = tree[node].rt;</span><br><span class="line">        tree[tot].v = k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    tot++;</span><br><span class="line">    tree[tot].lt = tree[node].lt, tree[tot].rt = tree[node].rt;</span><br><span class="line">    <span class="type">int</span> tmp = tot;</span><br><span class="line">    <span class="type">int</span> mid = tree[node].lt + tree[node].rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        tree[tot].l = tot + <span class="number">1</span>, tree[tot].r = tree[node].r;</span><br><span class="line">        <span class="built_in">update</span>(tree[node].l, x, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tree[tot].l = tree[node].l, tree[tot].r = tot + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">update</span>(tree[node].r, x, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后解释是什么意思。</p><p>首先我们看 $8$ ~ $10$ 行，这里是新建一个节点。注意第 $10$ 行，我们先记一下 $tot$，为准备 $\text{pushup}$。</p><p>我们再看 $12$ ~ $15$ 行，这里的意思是 $x$ 在左儿子的区间内，所以结合图例我们可以看出：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z1qzcv8o.png" alt=""></p><p>我们发现，如果是这个节点的左节点要做修改，那么这个节点对应的新建的节点的左儿子就是接下来要新建的这个节点的左儿子节点的对应节点，我们可以算出编号为 $tot + 1$，然后新建节点的右孩子还是对应节点的右孩子。</p><p>然后如果是修改右孩子直接反过来即可。</p><p>再来看 $2$ ~ $7$ 行，这里是到了叶子节点，我们还是新建一个节点，然后将权值设为 $k$。记得要 <code>return ;</code></p><p><del>是不是很难？</del></p><h3 id="查询（-text-query-）-1"><a href="#查询（-text-query-）-1" class="headerlink" title="查询（$\text{query}$）"></a>查询（$\text{query}$）</h3><p>查询的话，直接向下搜，搜到叶子节点直接返回就行了：</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!tree[node].l &amp;&amp; !tree[node].r)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[node].v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = tree[node].lt + tree[node].rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tree[node].l, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tree[node].r, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很简单吧！注意只要从要求搜的 $root$ 就行了。</p><h3 id="最后（空间复杂度分析）"><a href="#最后（空间复杂度分析）" class="headerlink" title="最后（空间复杂度分析）"></a>最后（空间复杂度分析）</h3><p>注意，这里由于每次操作只更改 $\log_2N$ 个节点，所以只需要 $O(M \log_2N)$ 的空间就可以把所有历史版本的线段树全部记下来。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码就放上来吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;    <span class="comment">//注意这里时间会超，要开快读</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">      f = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    x = x * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = N * <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot;     <span class="comment">//节点个数</span></span><br><span class="line"><span class="type">int</span> len, root[M];  <span class="comment">//所有版本的根节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span>&#123;</span><br><span class="line">  <span class="type">int</span> lt, rt;    <span class="comment">//代表区间</span></span><br><span class="line">  <span class="type">int</span> l, r;   <span class="comment">//左右孩子</span></span><br><span class="line">  <span class="type">int</span> v;    <span class="comment">//代表值</span></span><br><span class="line">&#125;tree[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">  tree[node].v = tree[tree[node].l].v + tree[tree[node].r].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">    tree[node].lt = lt, tree[node].rt = rt;</span><br><span class="line">    tree[node].v = a[lt];</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  tot = <span class="built_in">max</span>(tot, node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  tree[node].lt = lt, tree[node].rt = rt;</span><br><span class="line">  tree[node].l = node &lt;&lt; <span class="number">1</span>, tree[node].r = node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!tree[node].l &amp;&amp; !tree[node].r)&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    tree[tot].lt = tree[node].lt, tree[tot].rt = tree[node].rt;</span><br><span class="line">    tree[tot].v = k;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  tot++;</span><br><span class="line">  tree[tot].lt = tree[node].lt, tree[tot].rt = tree[node].rt;</span><br><span class="line">  <span class="type">int</span> tmp = tot;</span><br><span class="line">  <span class="type">int</span> mid = tree[node].lt + tree[node].rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">    tree[tot].l = tot + <span class="number">1</span>, tree[tot].r = tree[node].r;</span><br><span class="line">    <span class="built_in">update</span>(tree[node].l, x, k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    tree[tot].l = tree[node].l, tree[tot].r = tot + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">update</span>(tree[node].r, x, k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushup</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!tree[node].l &amp;&amp; !tree[node].r)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[node].v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = tree[node].lt + tree[node].rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tree[node].l, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tree[node].r, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    a[i] = <span class="built_in">read</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  root[++len] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> v, op;</span><br><span class="line">    v = <span class="built_in">read</span>(), op = <span class="built_in">read</span>();</span><br><span class="line">    v++;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">int</span> x, k;</span><br><span class="line">      x = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">      root[++len] = tot + <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">update</span>(root[v], x, k);    <span class="comment">//注意从哪个版本开始找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      x = <span class="built_in">read</span>();</span><br><span class="line">      len++;</span><br><span class="line">      root[len] = root[v];   <span class="comment">//这里记一下版本根节点</span></span><br><span class="line">      cout &lt;&lt; <span class="built_in">query</span>(root[v], x) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">//这里也一样</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="疑问-amp-催更"><a href="#疑问-amp-催更" class="headerlink" title="疑问 &amp; 催更"></a>疑问 &amp; 催更</h2><p>请私信 $\color{red}\text{_Alexande_}$，这里有快速链接：<a href="https://www.luogu.com.cn/chat?uid=363006">$\text{Link}$</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
