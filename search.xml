<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>P7557 题解</title>
      <link href="/2022/06/12/P7557-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/P7557-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一道二分答案的水题"><a href="#一道二分答案的水题" class="headerlink" title="一道二分答案的水题"></a>一道二分答案的水题</h2><p>首先，你必须知道二分答案是什么（否则你来做这题干什么）。</p><p>其次，这题目有些坑。</p><span id="more"></span><h2 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h2><ol><li><p>必须排序，因为你综述引用的被引用的文章次数（简称输入的数）越大，那么 $h$ 指数<strong>可能</strong>就会越大，如果不排序，会错几个点。</p></li><li><p>题目说明最多有 $k$ 篇综述，而每篇综述只能引用 $l$ 篇论文，而且每篇论文只能引用<strong>一次</strong>，但是，每一篇综述都可以引用一篇文章一次，所以你可以看成有一篇综述，能引用 $k * l$ 篇文章，每篇文章能够引用 $k$ 次（题目简化版）。</p></li><li><p>题目说明 $k ≤ 10 ^ 5$，并且 $l ≤ 10 ^ 5$，所以要开长整型。</p></li></ol><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><ol><li><p>其中，最小值设为 $-1$，最大值设为$n + 1$。因为最小可能是 $0$，最大可能是 $n$，而最小值要减 $1$，最大值也要加 $1$，所以如上。</p></li><li><p>检查函数的设计。检查函数，只需判断如果 $c_i$ 大于 $x$，答案加 $1$， 然后如果 $c_i$ 加上 $k$ 大于 $x$ 并且这时的综述可引用次数大于<strong>等于</strong> $k$，答案加 $1$，并将综述可引用次数减去 $x - c_i$。</p></li><li><p>由于是求最大值，所以如果答案可行，应该是 $l = mid$，并且最后的输出是 $l$。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>你们最想要的，代码来喽：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, l, c[<span class="number">100005</span>], k;   <span class="comment">//开long long</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>, L = l * k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(c[i] &gt;= x)&#123;     <span class="comment">//如果不需要综述引用</span></span><br><span class="line">sum++;    <span class="comment">//答案++</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[i] &gt;= x - k &amp;&amp; L &gt;= x - c[i])&#123;    <span class="comment">//如果可以引用综述</span></span><br><span class="line">sum++;</span><br><span class="line">L -= (x - c[i]);   <span class="comment">//综述次数-=(x - c[i])</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum &gt;= x;    <span class="comment">//如果sum &gt;= x 为真，返回true，否则返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;    <span class="comment">//cmp排序函数</span></span><br><span class="line"><span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k &gt;&gt; l;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; c[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + n, cmp);   <span class="comment">//排序</span></span><br><span class="line"><span class="type">int</span> l = <span class="number">-1</span>, r = n + <span class="number">1</span>;    <span class="comment">//l和r要设清楚</span></span><br><span class="line"><span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid))&#123;   <span class="comment">//如果可行</span></span><br><span class="line">l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; l;    <span class="comment">//是输出l</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3467 题解</title>
      <link href="/2022/06/12/P3467-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/P3467-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一道思维水题"><a href="#一道思维水题" class="headerlink" title="一道思维水题"></a>一道思维水题</h2><p>首先，清楚题目理解障碍。</p><span id="more"></span><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>题目中的海报是可以这样贴的：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/0k67h861.png" alt=""></p><p>注意：画黑色框的是建筑物，红色框的是海报。</p><p>从这可以看出海报可以将 $n$ 个建筑物的侧面连起来。</p><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>我们可以显然看出贴满这 $n$ 个建筑物的侧面可以用 $n$ 张海报，因为每个建筑物的侧面都贴一张海报就是 $n$ 张海报了。</p><p>那么现在的难点就是如何减少海报的张数。建筑物侧面<strong>有可能</strong>为这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1dk8rnmt.png" alt=""></p><p>本来用四张海报贴的用三张海报就贴出来了（我只画了连起来的海报），但是如下不行：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/agvr9k3m.png" alt=""></p><p>虽然第一栋楼的高度和第四栋楼的高度一样，但是中间的楼比这两栋楼要矮，所以不能这么贴。</p><p>所以，当从第 $i$ 栋楼开始，可以一直贴到高度不大于（小于等于）第 $i$ 栋楼的楼。</p><p>那么怎样新开一张海报呢？无非只有两种情况：</p><ol><li><p>第一栋楼<strong>一定</strong>需要一张海报。</p></li><li><p>当这栋楼的高度大于前一栋楼的高度或者小于前一栋楼的高度（或者说，当不能再覆盖的时候）。</p></li></ol><p>所以，套进去算就可以了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>如何写代码呢？首先，开一个栈，存楼的高度，如果栈不为空并且能够覆盖下一栋楼时，就将栈里的元素 pop 到不能再覆盖的楼的。如果可以新开的话，就答案加加，继续查询能否覆盖，别忘记无论如何都要存下这栋楼的高度。</p><p>代码很短，关键是把上面的搞懂：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line"><span class="type">int</span> n, a[<span class="number">250005</span>], sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; a[i];   <span class="comment">//别忘记输入宽</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &gt; a[i])&#123;   <span class="comment">//如果能覆盖下一栋楼</span></span><br><span class="line">stk.<span class="built_in">pop</span>();   <span class="comment">//那就pop掉</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != a[i])&#123;   <span class="comment">//如果要新开一张海报</span></span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line">stk.<span class="built_in">push</span>(a[i]);    <span class="comment">//这栋楼的高度一定</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li><p>以上思路中始终没提宽一下，可能很多人猜到了，这题跟宽没关系。</p></li><li><p>为什么本题用栈，因为要记录覆盖的楼，而正好符合栈先进后出的性质。</p></li><li><p>拒绝抄袭题解，共创美好洛谷。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2206 题解</title>
      <link href="/2022/06/12/P2206-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/P2206-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="本题是一道模拟水题"><a href="#本题是一道模拟水题" class="headerlink" title="本题是一道模拟水题"></a>本题是一道模拟水题</h2><p>首先，分为两个部分：</p><ol><li><p>初始化。</p></li><li><p>移动操作。</p></li><li><p>一点细节。</p></li></ol><p>注意：本题解的坐标以矩阵的行列为标准。</p><span id="more"></span><h3 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1. 初始化"></a>1. 初始化</h3><p>第一步，初始化四只蹄子的位置：</p><p>FL 的坐标初始化为 $(0, 0)$，FR 的坐标初始化为 $(0, 1)$，RL 的坐标初始化为 $(1, 0)$，RR 的坐标初始化为 $(1, 1)$。</p><p>则开一个数组，存储每只蹄子的位置，可以方便一点。</p><p>第二步，给操作和蹄子编号：</p><p>将四只蹄子分别按照一二三四的顺序编号（蹄子的编号顺序自己定），写一个函数，也会方便一点。</p><p>随后，<strong>只将</strong> F，B，R，L 操作按照顺序编号，P 操作后面会单独处理。</p><p>第三步，维护最小最大的蹄子位置：</p><p>由于要求舞台的大小，所以得每次维护最小的坐标和最大的坐标（建议使用结构体），最后才能求出舞台的大小，所以只要设为 $10^9$ 和 $- 10^9$ 就可以了。</p><h3 id="2-移动操作"><a href="#2-移动操作" class="headerlink" title="2. 移动操作"></a>2. 移动操作</h3><p>移动操作又分为两个部分：</p><ol><li><p>上下左右。</p></li><li><p>旋转。</p></li></ol><p>第一部分，上下左右：</p><p>此时只要利用要移动的蹄子进行操作即可，顺便判断一下有没有蹄子重复和维护坐标最小值和最大值即可。</p><p>第二部分，旋转：</p><p>首先，推导旋转前与旋转后的坐标关系。</p><p>请看以下这幅图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/g2ljevx4.png" alt=""></p><p>其中我们假设现在被旋转点绕标准点<strong>顺时针</strong>旋转 $90$ 度，画的两个三角形是辅助图形，则可以得出各条边（只有辅助边）的长度和各个点的坐标（根据边的长度得到坐标）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/gwbayaah.png" alt=""></p><p>此时，清晰的发现，坐标为 $(x, y)$ 的点，顺时针旋转 $90$ 度后的坐标为 $(x + y’ - y, y + x - x’)$。</p><p>现在，就可以直接套公式了，这时不要判蹄子在一个格子里，因为是不可能两个蹄子在同一个格子里的，这一点可以自己动手推导。</p><h3 id="3-一点细节"><a href="#3-一点细节" class="headerlink" title="3. 一点细节"></a>3. 一点细节</h3><ol><li><p>我们可以利用循环节来建造一个方向数组，方便一点。</p></li><li><p>建一个变量，来维护 Bessie 的朝向，旋转时改变方向即可。</p></li><li><p>利用结构体，避免代码过长。</p></li><li><p>利用函数嵌套，代码有清晰性。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>以下是蒟蒻的代码，过长勿喷，亲测 AC：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奶牛芭蕾，原地址：http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=278</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;   <span class="comment">//方向数组节省代码量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, f = <span class="number">0</span>;    <span class="comment">//f 表示方向，0 表示朝北，2 表示朝南，3 表示朝西，1 表示朝东</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;_1, _2, p[<span class="number">5</span>];    <span class="comment">//_1 表示最左上角的蹄子，_2 表示最右下角的蹄子，p[] 表示维护四个蹄子的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示旋转中的操作</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">P</span><span class="params">(<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">f++;</span><br><span class="line">f %= <span class="number">4</span>;    <span class="comment">//改变朝向</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="type">int</span> t1 = p[id].x + p[i].y - p[id].y;    <span class="comment">//用 t1, t2 来维护旋转后的新位置</span></span><br><span class="line"><span class="type">int</span> t2 = p[id].y + p[id].x - p[i].x;</span><br><span class="line">p[i].x = t1;</span><br><span class="line">p[i].y = t2;</span><br><span class="line">_1.x = <span class="built_in">min</span>(_1.x, p[i].x);</span><br><span class="line">_1.y = <span class="built_in">min</span>(_1.y, p[i].y);</span><br><span class="line">_2.x = <span class="built_in">max</span>(_2.x, p[i].x);</span><br><span class="line">_2.y = <span class="built_in">max</span>(_2.y, p[i].y);    <span class="comment">//维护最小左上角和最大右下角</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查移动的位置有没有另外的蹄子</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">p[id].x = p[id].x + dx[(x + f) % <span class="number">4</span>];</span><br><span class="line">p[id].y = p[id].y + dy[(x + f) % <span class="number">4</span>];    <span class="comment">//%4 表示存在一个循环节</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">_1.x = <span class="built_in">min</span>(_1.x, p[i].x);</span><br><span class="line">_1.y = <span class="built_in">min</span>(_1.y, p[i].y);</span><br><span class="line">_2.x = <span class="built_in">max</span>(_2.x, p[i].x);</span><br><span class="line">_2.y = <span class="built_in">max</span>(_2.y, p[i].y);   <span class="comment">//时刻维护</span></span><br><span class="line"><span class="keyword">if</span>(i != id)&#123;</span><br><span class="line"><span class="keyword">if</span>(p[id].x == p[i].x &amp;&amp; p[id].y == p[i].y)&#123;    <span class="comment">//如果绊倒了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取蹄子编号的函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">R</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="string">&quot;FL&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="string">&quot;FR&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="string">&quot;RL&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s == <span class="string">&quot;RR&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按照编号 return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//转化字符编号，按照上下左右的顺序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">D</span><span class="params">(<span class="type">char</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="string">&#x27;R&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//帮助操作四个蹄子</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">()</span></span>&#123;</span><br><span class="line">string s;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line"><span class="type">int</span> id = <span class="built_in">R</span>(s.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">2</span>));    <span class="comment">//id 表示操作蹄子的编号,R() 为获取编号的函数</span></span><br><span class="line"><span class="type">char</span> tmp = s[<span class="number">2</span>];   <span class="comment">//x 表示操作符号</span></span><br><span class="line"><span class="comment">//操作区分为两个部分，带旋转和不带旋转</span></span><br><span class="line"><span class="keyword">if</span>(tmp != <span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line"><span class="type">int</span> xy = <span class="built_in">D</span>(tmp);   <span class="comment">//将字符转化成编号，由 D() 完成</span></span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Check</span>(id, xy))&#123;   <span class="comment">//Check() 检查移动的位置有没有另外的蹄子</span></span><br><span class="line">cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">P</span>(id);   <span class="comment">//P() 表示旋转中的操作</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;test.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line"><span class="built_in">freopen</span>(<span class="string">&quot;test.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line">_1.x = _1.y = <span class="number">1e9</span>;</span><br><span class="line">_2.x = _2.y = <span class="number">-1e9</span>;</span><br><span class="line">_1.x = <span class="built_in">min</span>(p[<span class="number">0</span>].x, <span class="built_in">min</span>(p[<span class="number">1</span>].x, <span class="built_in">min</span>(p[<span class="number">2</span>].x, p[<span class="number">3</span>].x)));</span><br><span class="line">_1.y = <span class="built_in">min</span>(p[<span class="number">0</span>].y, <span class="built_in">min</span>(p[<span class="number">1</span>].y, <span class="built_in">min</span>(p[<span class="number">2</span>].y, p[<span class="number">3</span>].y)));</span><br><span class="line">_2.x = <span class="built_in">max</span>(p[<span class="number">0</span>].x, <span class="built_in">max</span>(p[<span class="number">1</span>].x, <span class="built_in">max</span>(p[<span class="number">2</span>].x, p[<span class="number">3</span>].x)));</span><br><span class="line">_2.y = <span class="built_in">max</span>(p[<span class="number">0</span>].y, <span class="built_in">max</span>(p[<span class="number">1</span>].y, <span class="built_in">max</span>(p[<span class="number">2</span>].y, p[<span class="number">3</span>].y)));</span><br><span class="line">p[<span class="number">0</span>].x = <span class="number">0</span>, p[<span class="number">0</span>].y = <span class="number">0</span>;    <span class="comment">//分别按照前左蹄，前右蹄，后左蹄，后右蹄的顺序排列</span></span><br><span class="line">p[<span class="number">1</span>].x = <span class="number">0</span>, p[<span class="number">1</span>].y = <span class="number">1</span>;</span><br><span class="line">p[<span class="number">2</span>].x = <span class="number">1</span>, p[<span class="number">2</span>].y = <span class="number">0</span>;</span><br><span class="line">p[<span class="number">3</span>].x = <span class="number">1</span>, p[<span class="number">3</span>].y = <span class="number">1</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">help</span>();   <span class="comment">//帮助操作四个蹄子</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (_2.x - _1.x + <span class="number">1</span>) * (_2.y - _1.y + <span class="number">1</span>);    <span class="comment">//输出矩形大小</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1102E 题解</title>
      <link href="/2022/06/12/CF1102E-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/CF1102E-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一道好题"><a href="#一道好题" class="headerlink" title="一道好题"></a>一道好题</h2><p>首先，从题目三个条件中寻找突破口。</p><p>题目说明 $b<em>{i + 1}$ 只可能等于 $b_i + 1$ 或者 $b_i$，并且 $a_i = a_j$ 时，$b_i = b_j$，则对于两个相同的数 $a_i, a_j(i \leq j)$，肯定 $b_i = b</em>{i + 1} = \cdots = b_{j - 1} = b_j$，可以自己想一下为什么。</p><p>然后，就可以将序列 $a$ 分为很多个区间，此时这些区间里的数只有两种状态，自己也可以想一下是怎么一回事。</p><span id="more"></span><p>但是这很多个区间有可能是交叉的，比如说以下样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 1 3 2</span><br></pre></td></tr></table></figure><p>此时，第一个区间为 $(1, 3)$ (注：第一个数代表左端点，第二个数代表右端点)，第二个区间为 $(2, 4)$，明显有交叉部分。</p><p>在这里，我们可以利用并查集来合并区间，但是这种方法过于复杂，我们可以利用一种更为简洁的方法来合并，提供算法流程：</p><ol><li><p>把所有的区间按照上述方法存进数组。</p></li><li><p>把数组按照左端点的大小排序。</p></li><li><p>如果当前的左端点小于之前的最大右端点（因为右端点没有排序），就合并上一个和当前的区间。</p></li><li><p>如果违反流程 $3$，则计数器加加，表示区间加一个。</p></li></ol><p>然后，区间（互不交叉）的数量就成功的统计完了，但需要注意的是：</p><ol><li><p>由于 $a_i \leq 10^9$，所以数组不可能开的下这么大，要使用 map。</p></li><li><p>注意计数器初始化为 $1$，自己想想为什么。</p></li></ol><p>然后，知道了有多少个区间（默认互不交叉，默认有 $cnt$ 个区间），就需要用到数学思维：</p><p>每个区间都有两种选择（前面的加强版），因为根据第二条规则。所以本来答案应该是 $2^{cnt}$，但是 $b_1 = 0$，所以有一个区间只有一种选择，则答案为 $2^{cnt - 1}$。</p><p>请注意取模。</p><p>至于次方怎么求，请学习快速幂或者循环求次方，这里作者用得是快速幂（装逼）。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码来了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long   <span class="comment">//由于可能会超一点点，所以开 long long</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">998244353</span>;   <span class="comment">//常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, a[<span class="number">200005</span>], len, cnt = <span class="number">1</span>;</span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mini, maxi;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  <span class="type">int</span> l, r;</span><br><span class="line">&#125;c[<span class="number">200005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fastpow</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> p)</span></span>&#123;    <span class="comment">//快速幂</span></span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)&#123;</span><br><span class="line">    <span class="keyword">if</span>(b &amp; <span class="number">1</span>)&#123;</span><br><span class="line">      ans = a % p * ans % p % p;</span><br><span class="line">    &#125;</span><br><span class="line">    b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    a = a % p * a % p % p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x.l &lt; y.l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">    <span class="keyword">if</span>(maxi[a[i]] == <span class="number">0</span>)&#123;</span><br><span class="line">      maxi[a[i]] = i;      <span class="comment">//求数 a[i] 在序列里最晚出现在哪里</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(mini[a[i]] == <span class="number">0</span>)&#123;</span><br><span class="line">      mini[a[i]] = i;     <span class="comment">//反之，求最早的</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    c[++len].l = mini[a[i]];     <span class="comment">//存到数组里</span></span><br><span class="line">    c[len].r = maxi[a[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + n, cmp);</span><br><span class="line">  <span class="type">int</span> maxi = c[<span class="number">1</span>].r;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;    <span class="comment">//求有多少个区间</span></span><br><span class="line">    <span class="keyword">if</span>(c[i].l &gt;= maxi)&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    maxi = <span class="built_in">max</span>(maxi, c[i].r);</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">fastpow</span>(<span class="number">2</span>, cnt - <span class="number">1</span>, mod);    <span class="comment">//输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后收尾"><a href="#最后收尾" class="headerlink" title="最后收尾"></a>最后收尾</h2><p>中间有些细节没讲，可以细细琢磨。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AT3850 题解</title>
      <link href="/2022/06/12/AT3850-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/AT3850-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="一道水题"><a href="#一道水题" class="headerlink" title="一道水题"></a>一道水题</h2><p>本人用从 $5$ 分钟切了。</p><p>说实话还是挺简单的，有两种思路。</p><span id="more"></span><h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>对于每次操作，暴力枚举，$l_i$ 到 $r_i$ 里的所有数，对于每一次枚举，需要花费 $O(\sqrt{x})$ 的时间（其中 $x$ 为枚举的数）。但是时间复杂度是 $O(NQ)$，其中 $N$ 为 $10^5$，显然会超时，此时，我们需要一个神奇的东西。</p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>没错，你通过<del>看了标签的</del>你的经验发现，对于多次询问，我们可以利用预处理，把 $1$ 到 $10^5$ 之内的数直接算出来，再维护一个前缀和数组，$sum<em>i$ 表示从 $1$ 到 $i$ 里符合的数有多少个。那么对于最后的答案，就是 $sum</em>{r<em>i} - sum</em>{l_i - 1}$。此时，时间复杂度已经与 $Q$ 无关了，成功的将时间复杂度优化到了 $O(N)$。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>判质数不会的可以观摩其他大佬的代码，其余的就好说了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int q, sum[100005];</span><br><span class="line"></span><br><span class="line">bool zhi(int x)&#123;</span><br><span class="line">  if(x &lt; 2)&#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  for(int i = 2; i &lt;= sqrt(x); i++)&#123;    //利用平方根判质数</span><br><span class="line">    if(x % i == 0)&#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void shai_2017(int x)&#123;</span><br><span class="line">  for(int i = 1; i &lt;= x; i++)&#123;     //x为枚举的范围</span><br><span class="line">    if(zhi(i) &amp;&amp; zhi((i + 1) / 2))&#123;</span><br><span class="line">      sum[i] = sum[i - 1] + 1;    //如果符合条件</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      sum[i] = sum[i - 1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Solve()&#123;</span><br><span class="line">  shai_2017(100005);    //预处理函数</span><br><span class="line">  cin &gt;&gt; q;</span><br><span class="line">  for(int i = 1; i &lt;= q; i++)&#123;</span><br><span class="line">    int l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    cout &lt;&lt; sum[r] - sum[l - 1] &lt;&lt; endl;    //O(1) 处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  Solve();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1614B 题解</title>
      <link href="/2022/06/12/CF1614B-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/CF1614B-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="感言"><a href="#感言" class="headerlink" title="感言"></a>感言</h2><p>自己五分钟水完了（真的哦）。</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于说输出任意一种方案都行，以不妨设 $0$ 号建筑在位置 $X$。</p><p>此时，我们可以发现，当一栋建筑物来回访问的次数越多，这栋建筑物就要离 $X$ 越近，才能使得时间越小。</p><p>那么，怎么确定 $n + 1$ 栋楼的位置呢？</p><p>我们可以发现，离 $X$ 最近的位置有两个（仅指整数位置），分别是 $X - 1$ 和 $X + 1$，同理，第二近的位置也有两个，分别是 $X - 2$ 和 $X + 2$。</p><p>此时，我们按照这 $n + 1$ 栋楼的访问次数排序，再依次对应 $X - 1, X + 1, X - 2, X + 2…$，最终再还原输出就可以了。</p><p>注意，$X$ 可以为任意值，但由于数据卡得很紧，这里还是设为 $0$ 比较保险。还有，一定要<strong>开 long long</strong>，其次，时间乘 $2$，可以自己想想为什么。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>思路有了，代码就到手了（不是 ctj）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">long long t, n, b[200005], len, f, sum;</span><br><span class="line"></span><br><span class="line">struct node&#123;</span><br><span class="line">  long long zhi, wei, shu;    //shu 为位置，wei 为记录是第几栋楼，zhi为访问次数</span><br><span class="line">&#125;a[200005];</span><br><span class="line"></span><br><span class="line">bool cmp(node x, node y)&#123;</span><br><span class="line">  return x.zhi &gt; y.zhi;    //排序</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool cmp2(node x, node y)&#123;</span><br><span class="line">  return x.wei &lt; y.wei;    //还原</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Solve()&#123;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  while(t--)&#123;</span><br><span class="line">    len = f = sum = 0;    //sum 来统计时间，f 来记录位置。</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">      cin &gt;&gt; a[i].zhi;</span><br><span class="line">      a[i].wei = i;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + 1, a + 1 + n, cmp);   //按照访问次数排序</span><br><span class="line">    a[0].shu = 0;</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;    //分配位置</span><br><span class="line">      if(i &amp; 1)&#123;   //别吓傻了，i &amp; 1 是判断 i 是否为奇数</span><br><span class="line">        f++;</span><br><span class="line">        a[++len].shu = f;</span><br><span class="line">      &#125;</span><br><span class="line">      else&#123;</span><br><span class="line">        a[++len].shu = -f;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a + 1, a + 1 + n, cmp2);</span><br><span class="line">    for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">      sum += (abs(a[i].shu - 0) * a[i].zhi);    //求时间</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum * 2 &lt;&lt; endl;   //由于要来回都走，所以要乘 2</span><br><span class="line">    for(int i = 0; i &lt;= n; i++)&#123;</span><br><span class="line">      cout &lt;&lt; a[i].shu &lt;&lt; &quot; &quot;;   //输出位置</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">  Solve();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UVA11572 题解</title>
      <link href="/2022/06/12/UVA11572-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/UVA11572-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>翻译成人话：求一个序列的最长连续无重复数字的子序列长度。</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>考虑暴力做法，双重循环枚举子序列，光是 $O(N^2)$ 的时间就过不去，所以考虑优化。</p><p>考虑使用滑动窗口，紫书上说：</p><p>定义 $last_i$ 表示 $a_i$ 上一次出现在哪个位置，如果在之前没有出现，则 $last_i$ 等于 $-1$。</p><p>然后求 $last_i$ 的过程可以利用 <code>set</code> 或者 <code>map</code> 来辅助完成。当滑动窗口时，判有没有重复的数字就只需要 $O(1)$ 的复杂度了。</p><p>然后按照滑动窗口的模板写就可以啦！注意记得 <code>set</code> 或 <code>map</code> 要清空。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>码风丑陋，注意观看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, n, a[<span class="number">1000005</span>], last[<span class="number">1000005</span>];</span><br><span class="line"></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; vis;   <span class="comment">//一个好像是利用 hash 表实现的 map，会快一点。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//求出 last[i]</span></span><br><span class="line">      <span class="keyword">if</span>(!vis[a[i]])&#123;    <span class="comment">//如果之前没有出现过</span></span><br><span class="line">        last[i] = <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        last[i] = vis[a[i]];    <span class="comment">//vis[a[i]] 表示 a[i] 上一次的位置</span></span><br><span class="line">      &#125;</span><br><span class="line">      vis[a[i]] = i;    <span class="comment">//更新</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>, maxi = <span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">while</span>(r &lt;= n)&#123;     <span class="comment">//滑动窗口模板</span></span><br><span class="line">      <span class="keyword">while</span>(r &lt;= n &amp;&amp; l &gt; last[r])&#123;     <span class="comment">//利用 last[i] 判断</span></span><br><span class="line">        r++;</span><br><span class="line">      &#125;</span><br><span class="line">      maxi = <span class="built_in">max</span>(maxi, r - l);    <span class="comment">//维护最长长度</span></span><br><span class="line">      l++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxi &lt;&lt; endl;</span><br><span class="line">    vis.<span class="built_in">clear</span>();    <span class="comment">//清空</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF660C 题解</title>
      <link href="/2022/06/12/CF660C-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/CF660C-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h2><p>考虑暴力，枚举序列中所有连续子序列的 $l$ 和 $r$，最好的方法也需要 $O(N^2)$ 的时间（前缀和维护），所以考虑优化。</p><span id="more"></span><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><p>我们发现，题目简意就是找一个最长的含有 $k$ 个 $0$ 子序列的长度，并全部改成 $1$，那么就有点像双指针了。</p><p>这道题目在优化的关键是：当已选子序列后面还有 $1$ 时，可以继续延伸下去，就没必要再枚举了。那么在双指针上怎么实现呢？</p><p>我们可以再添加一个循环，循环往后找 $1$。那么这样会不会影响复杂度呢？<br>我们可以这么想，你循环找的 $1$ 越多，那么下一次找的 $r$ 就会越大，循环次数就会越少，因此不影响时间复杂度。</p><p>最后注意一些循环变量的问题就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, a[<span class="number">300005</span>], tot, ans = <span class="number">-1e9</span>, zi, zj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">for</span>(; j &lt;= n &amp;&amp; tot &lt; k; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!a[j])&#123;    <span class="comment">//0 的个数</span></span><br><span class="line">        tot++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(; j &lt;= n; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!a[j])&#123;     <span class="comment">//往后延伸</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j - i &gt; ans &amp;&amp; tot &lt;= k)&#123;    <span class="comment">//如果合法</span></span><br><span class="line">      ans = j - i;      <span class="comment">//统计答案</span></span><br><span class="line">      zi = i;</span><br><span class="line">      zj = j - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!a[i])&#123;     <span class="comment">//注意，i 最后还多加了一次</span></span><br><span class="line">      tot--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= zi - <span class="number">1</span>; i++)&#123;</span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = zi; i &lt;= zj; i++)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = zj + <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//颓废的输出</span></span><br><span class="line">    cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3669 题解</title>
      <link href="/2022/06/12/P3669-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/P3669-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先根据纪念品分组这道题可知肯定是最小的配最大的最划算，所以要排遍序。可是将每头奶牛都用数组存起来的话会炸，所以考虑让一段奶牛和一段奶牛这样的配对，于是便想到了双指针。</p><span id="more"></span><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>定义指针 $l$ 和 $r$，让这两个指针往中间扫。如果 $a_l &lt; a_r$，则 $l$ 加一，$a_r$ 的 $y$ 减去 $a_l$ 的 $y$。反之，$r$ 减一，$a_l$ 的 $y$ 减去 $a_r$ 的 $y$。当 $l &gt; r$ 时停止，此时统计一下前面 $a_l + a_r$ 的最大值就可以了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">  <span class="type">int</span> x, y;</span><br><span class="line">&#125;a[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node i, node j)</span></span>&#123;    <span class="comment">//排序函数</span></span><br><span class="line">  <span class="keyword">return</span> i.y &lt; j.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i].x &gt;&gt; a[i].y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);    <span class="comment">//按照时间排序</span></span><br><span class="line">  <span class="type">int</span> l = <span class="number">1</span>, r = n, ans = <span class="number">-1e9</span>;</span><br><span class="line">  <span class="keyword">while</span>(l &lt;= r)&#123;    <span class="comment">//一定注意，本题数据太水，l &lt; r 也能过，但 l &lt;= r 才是正解（因为到了最后自己和自己分）</span></span><br><span class="line">    <span class="keyword">if</span>(a[l].x &lt; a[r].x)&#123;</span><br><span class="line">      a[r].x -= a[l].x;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, a[l].y + a[r].y);    <span class="comment">//第一种情况</span></span><br><span class="line">      l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a[l].x &gt; a[r].x)&#123;    <span class="comment">//第二种</span></span><br><span class="line">      a[l].x -= a[r].x;</span><br><span class="line">      ans = <span class="built_in">max</span>(ans, a[l].y + a[r].y);</span><br><span class="line">      r--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;     <span class="comment">//这一种没讲，是两个都相等的情况</span></span><br><span class="line">      ans = <span class="built_in">max</span>(ans, a[l].y + a[r].y);</span><br><span class="line">      l++;</span><br><span class="line">      r--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF701C 题解</title>
      <link href="/2022/06/12/CF701C-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/CF701C-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>不说多了，建议把双指针和逛画展这道题学一下，这道题就会了。</p><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, cnt[<span class="number">2005</span>], zi, zj, a[<span class="number">100005</span>], t[<span class="number">2005</span>], m;</span><br><span class="line"><span class="type">char</span> s[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; s[i];</span><br><span class="line">    a[i] = (<span class="type">int</span>)s[i];</span><br><span class="line">    <span class="keyword">if</span>(!t[a[i]])&#123;    <span class="comment">//这里使用另外一个数组</span></span><br><span class="line">      m++;</span><br><span class="line">    &#125;</span><br><span class="line">    t[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1e9</span>, tot = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//双指针</span></span><br><span class="line">    <span class="keyword">for</span>(; j &lt;= n &amp;&amp; tot &lt; m; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!cnt[a[j]])&#123;     <span class="comment">//cnt 记录字母出现次数</span></span><br><span class="line">        tot++;</span><br><span class="line">      &#125;</span><br><span class="line">      cnt[a[j]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j - i &lt; ans &amp;&amp; tot == m)&#123;</span><br><span class="line">      ans = j - i;     <span class="comment">//记录答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    cnt[a[i]]--;</span><br><span class="line">    <span class="keyword">if</span>(!cnt[a[i]])&#123;    <span class="comment">//注意变量问题</span></span><br><span class="line">      tot--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF915D 题解</title>
      <link href="/2022/06/12/CF915D-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/CF915D-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前面的话"><a href="#前面的话" class="headerlink" title="前面的话"></a>前面的话</h2><p>此题目洛谷评分错误，根本没有紫题难度。</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最开始的想法：枚举删除的每一条边，做一遍拓扑排序，最后直接暴力得出答案。</p><p>但是，仔细分析时间复杂度：$O(m(n + m))$，根本过不去，所以想优化。</p><p>我们可以发现，当有 $x$ 条边是指向 $u$ 时，我们在上面的算法流程中就会把每一条边都枚举一次，枚举 $x$ 次。但仔细想想，对于每次拓扑排序的结果只跟 $in$ 数组有关，如果每次拓扑排序中的 $in$ 数组没有改变，那么排序的结果就不会改变。而这 $x$ 次对应的 $in_u$ 全部都是一样的，也就是说，这 $x$ 次操作只用做 $1$ 次！！！</p><p>也就是说，我们不必循环 $m$ 条边，我们只需要循环每个入度不为 $0$ 的点就可以了（因为都没有边指向它，干什么去拓扑）。</p><p>那么时间复杂度就降成了 $O(n(n + m))$。主要还是思考 $in$ 数组的作用。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码来啦：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long    <span class="comment">//本作者手残打上去的，千万别打</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, u[<span class="number">100005</span>], v[<span class="number">100005</span>], in[<span class="number">505</span>], IN[<span class="number">505</span>];   <span class="comment">//IN 数组用来替换 in 数组。因为你 in 数组全都变为 0 了还搞什么呀</span></span><br><span class="line"><span class="type">bool</span> e[<span class="number">505</span>][<span class="number">505</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">topo</span><span class="params">()</span></span>&#123;    <span class="comment">//简单的拓扑模板，不会的可以上网搜</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    IN[i] = in[i];   <span class="comment">//替换</span></span><br><span class="line">  &#125;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!IN[i])&#123;</span><br><span class="line">      q.<span class="built_in">push</span>(i);    <span class="comment">//首次入队</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    cnt++;     <span class="comment">//这个 cnt 是用来判环的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(!e[x][i])&#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      IN[i]--;</span><br><span class="line">      <span class="keyword">if</span>(!IN[i])&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cnt == n;    <span class="comment">//如果没环，那么 n 个点一定都算过了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    cin &gt;&gt; u[i] &gt;&gt; v[i];</span><br><span class="line">    in[v[i]]++;    <span class="comment">//统计入度</span></span><br><span class="line">    e[u[i]][v[i]] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">topo</span>())&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(in[i])&#123;     <span class="comment">//要入度为 0 才删除</span></span><br><span class="line">      in[i]--;    <span class="comment">//删掉一个点的入度</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">topo</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      in[i]++;    <span class="comment">//回溯</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;     <span class="comment">//这个 signed 不用管它</span></span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P7992 题解</title>
      <link href="/2022/06/12/P7992-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/P7992-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>本题过于<del>简单</del>，但是要求掌握差分（要开长整型）。</p><span id="more"></span><h2 id="10pts-的做法"><a href="#10pts-的做法" class="headerlink" title="$10pts$ 的做法"></a>$10pts$ 的做法</h2><p>直接暴力枚举每个 $k$，然后再花 $O(n^2)$ 的时间来枚举两个区间。</p><p>然后，你就可以得到 $10pts$ 的好成绩。</p><p>代码：<a href="https://www.luogu.com.cn/paste/l82vidp8">这里</a>。</p><h2 id="25pts-的做法"><a href="#25pts-的做法" class="headerlink" title="$25pts$ 的做法"></a>$25pts$ 的做法</h2><p>还是枚举两个区间，我们发现一组区间只有可能对答案 $a_i + a_j$ 到 $b_i + b_j$ 之间的 $k$ 做出贡献，所以此时可以用差分来维护答案序列，时间就是 $O(n^2)$，而不需要判断多余的 $k$，可以获得 $25pts$。</p><p>代码：<a href="https://www.luogu.com.cn/paste/akp9ijel">这里</a>。</p><h2 id="100pts-的做法"><a href="#100pts-的做法" class="headerlink" title="$100pts$ 的做法"></a>$100pts$ 的做法</h2><p>我们可以发现，对于我们做的差分操作，是可以<strong>分开</strong>进行的。然后我们又发现，$n$ 很大，$m$ 却很小，这说明在差分数组的一个地方<strong>可能</strong>会有很多次相加，所以考虑将这么多次相加变成一次相加。</p><p>我们可以思考，为什么要枚举两个区间呢？枚举这两个区间的左端点和右端点不好吗（在此指的是值）？所以，我们可以用双重循环来枚举两个区间的<strong>端点</strong>，注意，左端点和右端点可以同时枚举，但枚举的不是同一个区间的端点。此时我们发现，根据加乘原理，在枚举端点的值为 $i$ 和 $j$ 的情况下，我们差分数组加的应该是左端点为 $i$ 的个数 $\times$ 左端点为 $j$ 的个数（非常简单，在此不做解释），而右端点呢，也是一样。那么，如何统计端点为 $i$ 的个数呢？很简单，用个桶就行了。</p><p>实现方法：</p><p>在此设差分数组为 $d$。</p><p>设立数组 $ca$ 和 $cb$，分别表示记录左端点和右端点的出现次数。然后枚举 $i$ 和 $j$，在此指的是值。将 $d<em>{i + j} + (ca_i \times ca_j)$，指的是左端点，将 $d</em>{i + j + 1} - (cb_i \times cb_j)$，指的是右端点。然后对 $d$ 求前缀和即可。</p><p>代码：<a href="https://www.luogu.com.cn/paste/ry4ack5a">这里</a>。</p><h2 id="最后的话"><a href="#最后的话" class="headerlink" title="最后的话"></a>最后的话</h2><p>为什么要开长整型？因为 $n$ 有 $10^5$ 这么大，然而一个 $k$ 可能会有 $n^2$ 这么大，所以要开长整型。</p><p>最后！拒绝抄袭题解，共创美好洛谷。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA11987 题解</title>
      <link href="/2022/06/12/UVA11987-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/UVA11987-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>由于原文没有正确翻译，现在来重新描述一下题意：</p><p>现在你有一个类似于并查集的数据结构，并且可以支持以下操作：</p><ol><li><p>输入两个数 $p, q$，表示将 $p$ 所在的集合和 $q$ 所在的集合合并。</p></li><li><p>输入两个数 $p, q$，表示将 $p$ 这个数移到 $q$ 所在的集合里。</p></li><li><p>输入一个数 $p$，表示询问 $p$ 所在的集合里的数的个数和所有数的总和。</p></li></ol><p>这种数据结构规定最初 $p$ 的集合里只有 $p$ 这个数字。</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这道题目一看就是一道并查集的水题，$1$ 操作和 $3$ 操作都可以用普通的并查集实现，但是如果 $2$ 操作用普通并查集实现，就会出现问题。下面举个栗子：</p><p>某次操作后的集合状态如下。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/cny1dvyv.png" alt=""></p><p>现在执行操作 $2\ 1\ 5$，如果我们用普通并查集就会出现以下情况。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/osx1glhs.png" alt=""></p><p>现在我们可以发现，$3$ 和 $2$ 一同连着 $1$ 飞走了。</p><p>我们总结之后发现，会出现这种情况的原因是在第一个集合内，$1$ 是这个集合内某一颗子树的根节点（理解什么意思就行），也就是说，我们不想让这种情况发生，只能让所有的节点为这个集合/树的叶子节点，才能保证它们安然无恙的离开。</p><p>所以引入了一个概念：虚点。</p><p>具体操作是这样的：</p><p>我们可以对每个数 $i$ 建立虚点 $i + n$ 为它的上司。还是用上面那个栗子来理解：</p><p>然后建立虚点就会变成这样：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/s5n18t4u.png" alt=""></p><p>然后再执行上面那个操作就是这样。</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1dqcvqe6.png" alt=""></p><p>是不是很妙。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>只要思路理解了，代码应该就能打出来，这里就不给出代码了。作者最后提一句：并查集要开双倍空间。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF229B 题解</title>
      <link href="/2022/06/12/CF229B-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/CF229B-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个图，有 $n$ 个点 $m$ 边，对于每个点 $i$ 都有 $k_i$ 个限制，因此在某些时候连向 $i$ 的边就不能使用。请问你 $1$ 到 $n$ 的最短路。</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接 SPFA + map 水过。</p><p>我们可以这样想，在每个点中如果有限制的话，那么我们在 SPFA 的时候就可以一次一次判断当前是否能够松弛，如果能，就松弛，如果不能，就直接最短路 $+ 1$。因此，伪代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(如果不能行)&#123;</span><br><span class="line">  跳到下一个时间</span><br><span class="line">&#125;</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>那么，问题就在我们如何判断行不行。</p><p>这时，依靠输入格式和数据范围，我们自然可以想到 vector，依靠查找一个元素在不在序列中，我们又自然想到了 lower_bound。</p><p>所以，我们可以利用 map 来解决这两个问题合并的问题（友情提示：map 常数过大，所以，你知道的）。</p><p>我们定义一个 map 数组，用来标记第 $i$ 个点不能用的所有时刻，如下（$N$ 表示点的个数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; book[N];</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>这样，上面那个问题就可以轻松解决，这里代码片段就不给了。</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>那么，这里给出一点可能出错的问题。有人的代码片段可能是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(book[点][dis[点]])&#123;</span><br><span class="line">  dis[点]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中点代表我们从队列中取出来的点。</p><p>这里的错误连样例都检查不出来，所以提一下。</p><p>为什么不对，因为最短路的修改是基于连出去的点，而从队列中取出来的点是已经经过松弛的点了，但是你现在又修改了，所以才会不对。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码来咯：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;     <span class="comment">// 卡常的快读</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">      f = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    x = x * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; book[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">edges[tot].to = v;</span><br><span class="line">edges[tot].w = w;</span><br><span class="line">edges[tot].next = head[u];</span><br><span class="line">head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">1e18</span>;    <span class="comment">// 这里要设大一点</span></span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line">vis[s] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="type">int</span> tmp = dis[x];</span><br><span class="line"><span class="keyword">while</span>(book[x][tmp])&#123;   <span class="comment">// 进行判断</span></span><br><span class="line">tmp++;     <span class="comment">// 注意这里要新建一个变量 ++</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(tmp + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">dis[edges[i].to] = tmp + edges[i].w;</span><br><span class="line"><span class="keyword">if</span>(!vis[edges[i].to])&#123;</span><br><span class="line">q.<span class="built_in">push</span>(edges[i].to);    <span class="comment">// 普通的 SPFA</span></span><br><span class="line">vis[edges[i].to] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">u = <span class="built_in">read</span>();</span><br><span class="line">v = <span class="built_in">read</span>();</span><br><span class="line">w = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line"><span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line">k = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= k; j++)&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">t = <span class="built_in">read</span>();</span><br><span class="line">book[i][t] = <span class="literal">true</span>;   <span class="comment">// 进行标记</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SPFA</span>(<span class="number">1</span>);</span><br><span class="line">cout &lt;&lt; (dis[n] == <span class="number">1e18</span> ? <span class="number">-1</span> : dis[n]);  <span class="comment">// 记住这里要输出 -1</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1307D 题解</title>
      <link href="/2022/06/12/CF1307D-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/CF1307D-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给你一个图，再给你一个集合，让你在集合里连一条边，使得最短路最大（边权为 $1$）。</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们定义一些前置数组：</p><p>定义 $dis<em>i$ 表示 $1$ 到 $i$ 的最短路径，$dis2_i$ 表示 $i$ 到 $n$ 的最短路径，$d</em>{i,j}$ 表示 $i$ 到 $j$ 的最短路。</p><p>首先，我们知道，如果在集合中连一条边的话，那么 $newdis_n \le olddis_n$，那么这里以连的两个点为 $u, v$ 举例：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zw6awx0d.png" alt=""></p><p>那么此时就可以得出柿子：$dis_u + 1 + dis2_v \le dis_n$。</p><p>同理，如果 $dis_u + 1 + dis2_v \le dis_n$ 的话，那么就有 $dis_u + 1 + dis2_v \le dis_v + dis2_v$（道理如上）。</p><p>柿子 $dis<em>u + 1 + dis2_v \le dis_v + dis2_v$ 可以化简成 $dis_u + 1 \le dis_v$。移项后可以得出 $dis_v - dis_u \ge 1$，所以我们发现 $d</em>{u, v}$ 要尽可能小才行，所以我们可以按照 $dis<em>i$ 排序，每次的相邻两个 $i$ 和 $i + 1$ 就一定是可能的最小的 $d</em>{u, v}$。</p><p>由于最后的答案可能大于 $dis_n$，所以我们还要跟 $dis_n$ 比较一下。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long    <span class="comment">//开 long long</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, k, maxi = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> dis[<span class="number">3</span>][N];     <span class="comment">//这里是预处理两个 dis 数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> to, next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">  tot++;</span><br><span class="line">  edges[tot].to = v;</span><br><span class="line">  edges[tot].next = head[u];</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> k)</span></span>&#123;    <span class="comment">//dijkstra 模板，其实这里可以用 bfs</span></span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">dis[k][i] = <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[k][s] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[k][s], s));</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">top</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[x]) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span> + dis[k][x] &lt; dis[k][edges[i].to]) &#123;</span><br><span class="line">dis[k][edges[i].to] = <span class="number">1</span> + dis[k][x];</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[k][edges[i].to], edges[i].to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dis[<span class="number">1</span>][x] &lt; dis[<span class="number">1</span>][y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    <span class="built_in">add</span>(u, v);</span><br><span class="line">    <span class="built_in">add</span>(v, u);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dijkstra</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">dijkstra</span>(n, <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + k, cmp);    <span class="comment">//按照 dis[i] 排序</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++)&#123;</span><br><span class="line">    maxi = <span class="built_in">max</span>(maxi, dis[<span class="number">1</span>][a[i]] + dis[<span class="number">2</span>][a[i + <span class="number">1</span>]] + <span class="number">1</span>);    <span class="comment">//最后计算答案</span></span><br><span class="line">  &#125;</span><br><span class="line">  maxi = <span class="built_in">min</span>(maxi, dis[<span class="number">1</span>][n]);    <span class="comment">//还要跟 dis[n] 比一比</span></span><br><span class="line">  cout &lt;&lt; maxi &lt;&lt; endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UVA11090 题解</title>
      <link href="/2022/06/12/UVA11090-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/UVA11090-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>由于找环十分不好找，所以我们往枚举平均值的方面来想。</p><span id="more"></span><p>由于 $c$ 的值过大，所以考虑二分。</p><p>但是，我们二分的单调性在哪里呢？</p><p>我们设平均值为 $mid$，并且环上的边的数量为 $cnt$。则满足以下不等式：</p><script type="math/tex; mode=display">\sum\limits c_i \ge mid \times cnt</script><p>我们尝试移项，我们可以如此移项：</p><script type="math/tex; mode=display">\dfrac{\sum\limits c_i}{cnt} \ge mid</script><p>乍一看好像对答案没有什么用，没有关系，我们还有另外一种移项的方法：</p><script type="math/tex; mode=display">\dfrac{\sum\limits c_i}{mid} \ge cnt</script><p>也没有什么用，所以我们把所有的都移过来：</p><script type="math/tex; mode=display">\sum\limits c_i - mid \times cnt \ge 0</script><p>此时我们发现好像有点关系了，由于有 $cnt$ 个 $c$，所以我们又可以化简成：</p><script type="math/tex; mode=display">\sum\limits (c_i - mid) \ge 0</script><p>是不是此时还没有看出什么关系（反正我是这样的），没有关系，我们再乘个 $-1$：</p><script type="math/tex; mode=display">\sum\limits (mid - c_i) \le 0</script><p>此时我们就可以看出些什么了，$cnt$ 个值加起来 $\le 0$，这不就是负环吗？只不过把边权改成 $mid - c_i$ 罢了。</p><p>所以这个二分的单调性就是，当跑 SPFA 是察觉有负环的时候，便将 $mid$ 调小，否则调大就行了。</p><p>然后就是由于精度问题，所以 $l, r$ 的精度调到 $0.00001$ 就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p><del>自己写吧。</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
            <tag> 负环 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AT1224 题解</title>
      <link href="/2022/06/12/AT1224-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/AT1224-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="提前声明"><a href="#提前声明" class="headerlink" title="提前声明"></a>提前声明</h2><p>AT 的题目最后要换行，否则会 WA。</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>本人在考场上写不出正确思路，就用宝石串的方法写了一下。</p><p>我们发现，在宝石串这道题中我们是将两种颜色分别设为 $1$ 和 $-1$。但是，在本题中并不能这样进行变化，因为可能会出现错误情况。这里提供一种转化方式：</p><p>J 变为 $100000$，O 变为 $200001$，I 变为 $-300001$。</p><p>这样就可以避免错误情况了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long    <span class="comment">//注意，n 个 200001 相加会爆 int</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, maxi = <span class="number">-1e9</span>;</span><br><span class="line"><span class="type">char</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; vis;     <span class="comment">//因为有负数，所以用 map</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">if</span>(a[i] == <span class="string">&#x27;J&#x27;</span>)&#123;    <span class="comment">//如上所述</span></span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + <span class="number">100000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] + <span class="number">200001</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i] == <span class="string">&#x27;I&#x27;</span>)&#123;</span><br><span class="line">f[i] = f[i - <span class="number">1</span>] - <span class="number">300001</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i--)&#123;     <span class="comment">//记录每个 f[i] 最早出现的下标</span></span><br><span class="line">vis[(<span class="type">long</span> <span class="type">long</span>)f[i]] = i;</span><br><span class="line">&#125;</span><br><span class="line">vis[(<span class="type">long</span> <span class="type">long</span>)<span class="number">0</span>] = <span class="number">0</span>;    <span class="comment">//这里注意 0 最早出现在下标为 0 的位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">maxi = <span class="built_in">max</span>(maxi, i - vis[(<span class="type">long</span> <span class="type">long</span>)f[i]]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (maxi == <span class="number">-1e9</span> ? <span class="number">0</span> : maxi) &lt;&lt; endl;    <span class="comment">//如果是 1e9 输出 0 就行了（其实不写也没关系）</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P8267 题解</title>
      <link href="/2022/06/12/P8267-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/P8267-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先肯定暴力枚举 $0$ 到 $10^9$ 中的位置，然后就是时间爆炸。</p><span id="more"></span><p>我们考虑，假如有一头奶牛说 Bessie 躲在大于等于 $x$ 的位置上，那么无论 Bessie 在 $x + 1$ 或是 $x + 2$ 都是合法的，如果又有一头奶牛说 Bessie 躲在小于等于 $y$ 的位置上（保证 $x &lt; y$），那么 Bessie 躲在 $[x, y]$ 这个区间里的任意一个位置都是合法且<strong>等价</strong>的。</p><p>那么我们不必去枚举每一个位置，只需枚举一段区间里的任意一个数都行，由于包括等于，这里就可以用本身的位置枚举。</p><p>具体实现：</p><ol><li><p>枚举两头奶牛所说的话。</p></li><li><p>判断当前是否有撒谎的奶牛。</p></li><li><p>对于每一次枚举的奶牛，进行取最小值。</p></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码应该就很好实现了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, mini = <span class="number">1e9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i].c &gt;&gt; a[i].x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//枚举奶牛</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(a[j].c == <span class="string">&#x27;G&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j].x &gt; a[i].x)&#123; <span class="comment">//判断是否合法</span></span><br><span class="line">          ans++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a[j].c == <span class="string">&#x27;L&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[j].x &lt; a[i].x)&#123;</span><br><span class="line">          ans++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mini = <span class="built_in">min</span>(mini, ans);   <span class="comment">//取最小值</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; (mini == <span class="number">1e9</span> ? <span class="number">0</span> : mini);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>P8271 题解</title>
      <link href="/2022/06/12/P8271-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/P8271-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><del>话说 USACO 官方题解用得是暴力？</del></p><span id="more"></span><p>首先我们定义一种运算 $\bigotimes$，则 $a \bigotimes b$ 表示当一个字符串里只有 $a$ 和 $b$ 这两个字符时产生的最后的字符。</p><p>那么我们可以推出以下式子：</p><ol><li><p>$C \bigotimes C = \varnothing$，$O \bigotimes O = \varnothing$，$W \bigotimes W = \varnothing$。</p></li><li><p>$C \bigotimes O = W$，$O \bigotimes C = W$，$C \bigotimes W = O$，$W \bigotimes C = O$，$O \bigotimes W = C$，$W \bigotimes O = C$。</p></li><li><p>$\varnothing \bigotimes C = C$，$\varnothing \bigotimes O = O$，$\varnothing \bigotimes W = W$，$C \bigotimes \varnothing = C$，$O \bigotimes \varnothing = O$，$W \bigotimes \varnothing = W$。</p></li><li><p>$\varnothing \bigotimes \varnothing = \varnothing$。</p></li></ol><p>我们可以看出几个性质：</p><ol><li><p>$\bigotimes$ 这种运算满足交换律。</p></li><li><p>$\bigotimes$ 这种运算满足逆元。</p></li><li><p>自己试一试，$\bigotimes$ 这种运算满足结合律。</p></li></ol><p>所以我们考虑大力前缀和。</p><p>我们再把这三种字母编上号，就会发现 $\bigotimes$ 这种运算实际上就是异或！所以我们就可以用异或来解决这个问题了。</p><p>我们只需要把区间内的元素全部异或，如果等于 $1$ 那么就输出 YES，否则输出 NO。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long   <span class="comment">//防爆</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; s;</span><br><span class="line">s = <span class="string">&quot; &quot;</span> + s;</span><br><span class="line">sum[<span class="number">1</span>] = (s[<span class="number">1</span>] == <span class="string">&#x27;C&#x27;</span> ? <span class="number">1</span> : (s[<span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span> ? <span class="number">2</span> : <span class="number">3</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">sum[i] = (sum[i - <span class="number">1</span>] ^ (s[i] == <span class="string">&#x27;C&#x27;</span> ? <span class="number">1</span> : (s[i] == <span class="string">&#x27;O&#x27;</span> ? <span class="number">2</span> : <span class="number">3</span>)));</span><br><span class="line">&#125;    <span class="comment">//初始化前缀异或数组</span></span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span>(q--)&#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">cout &lt;&lt; ((sum[l - <span class="number">1</span>] ^ sum[r]) == <span class="number">1</span> ? <span class="string">&#x27;Y&#x27;</span> : <span class="string">&#x27;N&#x27;</span>);   <span class="comment">//这里只需要异或就可以得到最终结果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1684A 题解</title>
      <link href="/2022/06/12/CF1684A-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/CF1684A-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h2><p>Alice 和 Bob 在玩一个数列游戏，整个数列有 $n$ 个数。Alice 是先手，并且游戏是轮流制的。</p><p>到 Alice 时，她必须交换两个<strong>不同位置</strong>的数。到 Bob 时，他必须去掉整个数列的最后一位数。当整个数列只剩下一个数时，游戏结束。</p><p>你需要找到游戏结束时，可能剩下的最小的数。</p><span id="more"></span><h2 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h2><p>容易看出，如果想要结果尽可能小的话，就要把小的数尽量往前移，我们发现，在<strong>普通</strong>情况下，可以把任意一个数移到最前面，然后就不断作其余元素的交换操作。我们就可以把最小的数移到最前面，这样就可以保证答案最小！</p><p>然而 CF 是良心又良心的。我们再想一下，如果 $n = 2$ 并且最小值已经在第一个时呢？这时，我们发现，无论怎么移动，最后的结果只会是第二个数，这是唯一一种特例！（这里说良心是因为第一个样例就已经指出这个问题了！）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span>(t--)&#123;     <span class="comment">// t 组数据</span></span><br><span class="line">    <span class="type">int</span> mini = <span class="number">1e9</span>, pos;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(s[i] - <span class="string">&#x27;0&#x27;</span> &lt; mini)&#123;     <span class="comment">// 记录位置</span></span><br><span class="line">        mini = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        pos = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">2</span> &amp;&amp; pos == <span class="number">0</span>)&#123;    <span class="comment">// 特例</span></span><br><span class="line">      cout &lt;&lt; s[pos + <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      cout &lt;&lt; mini &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UVA12983 题解</title>
      <link href="/2022/06/12/UVA12983-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/UVA12983-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们首先设 $f_{i, j}$ 表示以 $i$ 结尾的长度为 $j$ 的最长上升子序列个数。</p><span id="more"></span><p>我们可以根据普通最长上升子序列的转移来推出本题的转移：$f<em>{i, j} += \sum\limits</em>{k = 1}^{i}{f_{k, j - 1}}$。</p><p>显然这时当 $a_k &lt; a_i$ 时才成立的。</p><p>但是此时复杂度太高，所以我们考虑优化。</p><p>简单的是，因为我们的转移有两个条件：</p><ol><li><p>$a_k &lt; a_i$。</p></li><li><p>$\sum\limits_{k = 1}^{i}$</p></li></ol><p>我们看出，正因为有这两个条件，所以我们可以用酷似逆序对的方法解决这个问题，所以我们就可以用树状数组优化了，注意每次要清空就行。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n, m, f[N][N], a[N], b[N]; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;    <span class="comment">//树状数组</span></span><br><span class="line"><span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">tree[x] += k;</span><br><span class="line">tree[x] %= mod;</span><br><span class="line">x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">ans += tree[x];</span><br><span class="line">ans %= mod;</span><br><span class="line">x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">help</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">b[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">unique</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n) - b - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">a[i] = <span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + len, a[i]) - b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> T = <span class="number">1</span>; T &lt;= t; T++)&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">f[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">help</span>(); <span class="comment">// 数据过大，需要离散化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="built_in">update</span>(a[i], f[i][j - <span class="number">1</span>]);</span><br><span class="line">f[i][j] += <span class="built_in">query</span>(a[i] - <span class="number">1</span>);</span><br><span class="line">f[i][j] %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(tree, <span class="number">0</span>, <span class="built_in">sizeof</span>(tree)); <span class="comment">//这里要清空，否则会重叠</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">ans += f[i][m];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Case #&quot;</span> &lt;&lt; T &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; ans % mod &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> DP </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4041 题解</title>
      <link href="/2022/06/12/P4041-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/P4041-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="事前规定"><a href="#事前规定" class="headerlink" title="事前规定"></a>事前规定</h2><p>我们把 $L$ 写成 $l$，$R$ 写成 $r$。</p><span id="more"></span><h2 id="问答环节"><a href="#问答环节" class="headerlink" title="问答环节"></a>问答环节</h2><p>Q：为什么看了看别人的题解，都是用的线段树呀？</p><p>A：因为操作既要区间修改，也要对 $l$ 和 $r$ 取 $\max$ 和 $\min$，普通的模拟无法满足我们的需求，所以我们需要用线段树。</p><p>Q：那用线段树来维护什么呢？</p><p>A：用线段树来维护最后给出的 $q$ 个值</p><p>Q：为什么本题的线段树需要维护 $\min$ 和 $\max$ 呢？</p><p>A：因为在最后我们需要对小于 $l$ 的数赋值为 $l$，大于 $r$ 的数赋值为 $r$，又因为我们的线段树不能一边维护这个东西，所以只能在最后根据 $\min$ 值 与 $\max$ 值来<del>暴力</del>赋值。</p><p>Q：为什么别的题解需要写关于赋值的 $tag$，不是直接赋值就可以了吗？</p><p>A：想啥呢？我们的赋值需要按照线段树区间修改的方式来修改，否则会超时的！</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>以上几点，都是萌新喜欢问的一些问题，现在来讲一下思路：</p><p>我们发现，针对于每一次操作，都是对于整个区间进行的，所以我们可以直接加上 $tag$，不用再写一大堆的 update 函数了。</p><p>然后对于每一次操作，我们就看一下有没有小于 $l$ 的数或是大于 $r$ 的数，有的话就直接赋值。</p><p>接下来分几个层次来讲：</p><ol><li><p>addtag1：打加/减法标记。</p></li><li><p>addtag2：打乘法标记。</p></li><li><p>addtag3：打操作 $4$ 的标记。</p></li><li><p>addtag4：打区间赋值的标记。</p></li></ol><h3 id="addtag1"><a href="#addtag1" class="headerlink" title="addtag1"></a>addtag1</h3><p>我们可以普通的打标记，由于加/减法是最低级的运算，所以不用考虑任何，直接加上加法标记即可。</p><p>Code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag1</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  maxi[node] += val;    <span class="comment">// maxi 和 mini 数组同样也得加上 val</span></span><br><span class="line">  mini[node] += val;</span><br><span class="line">  tag1[node] += val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addtag2"><a href="#addtag2" class="headerlink" title="addtag2"></a>addtag2</h3><p>我们根据运算知道：第一次如果乘了 $3$，第二次乘了 $5$，那么最后就乘了 $3 \times 5 = 15$，所以乘法标记是乘起来的关系。我们根据运算又知道：第一次如果加了 $3$，第二次乘了 $5$，那么最后就不经让<strong>原数</strong>乘了 $5$ 而且还加了 $3 \times 5 = 15$，所以加法标记也是乘的关系。由于操作 $4$ 的标记也是加法运算，所以跟上面同理。</p><p>Code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag2</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  maxi[node] *= val;   <span class="comment">//这里仍要乘上</span></span><br><span class="line">  mini[node] *= val;</span><br><span class="line">  tag2[node] *= val;</span><br><span class="line">  tag1[node] *= val;</span><br><span class="line">  tag3[node] *= val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addtag3"><a href="#addtag3" class="headerlink" title="addtag3"></a>addtag3</h3><p>由于这个操作有点怪，所以我们需巧妙的解决它：</p><p>我们首先按照 $a$ 的值排个序，由于操作时全局修改，所以不论怎么修改，最小的仍然还是最小的，最大的仍然还是最大的，所以我们在加的时候就不需要考虑变动的数了。</p><p>Code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag3</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  mini[node] += a[lt].x * val;   <span class="comment">//直接加上最小的乘上 val的可以了，最大值同理</span></span><br><span class="line">  maxi[node] += a[rt].x * val;</span><br><span class="line">  tag3[node] += val;   <span class="comment">//这里是加法运算，所以需要加起来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addtag4"><a href="#addtag4" class="headerlink" title="addtag4"></a>addtag4</h3><p>简单的赋值，只需要把所有标记还原为初始状态就行了。</p><p>Code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag4</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  maxi[node] = mini[node] = val;</span><br><span class="line">  tag4[node] = val;</span><br><span class="line">  tag1[node] = <span class="number">0</span>;</span><br><span class="line">  tag2[node] = <span class="number">1</span>;</span><br><span class="line">  tag3[node] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>四个标记全部讲完了，然后 pushdown 就直接按照运算优先级去打标记就可以了。</p><p>pushdown：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;   <span class="comment">//一定按照优先级去下传标记</span></span><br><span class="line">  <span class="keyword">if</span>(tag4[node] != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">addtag4</span>(node &lt;&lt; <span class="number">1</span>, tag4[node]);</span><br><span class="line">    <span class="built_in">addtag4</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tag4[node]);</span><br><span class="line">    tag4[node] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tag2[node] != <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">addtag2</span>(node &lt;&lt; <span class="number">1</span>, tag2[node]);</span><br><span class="line">    <span class="built_in">addtag2</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tag2[node]);</span><br><span class="line">    tag2[node] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tag1[node] != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">addtag1</span>(node &lt;&lt; <span class="number">1</span>, tag1[node]);</span><br><span class="line">    <span class="built_in">addtag1</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tag1[node]);</span><br><span class="line">    tag1[node] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tag3[node] != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">addtag3</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, tag3[node]);</span><br><span class="line">    <span class="built_in">addtag3</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, tag3[node]);</span><br><span class="line">    tag3[node] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后简简单单的赋值操作一下就可以了。</p><p>赋值操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update_Max</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(mini[node] &gt; R)&#123;</span><br><span class="line">    <span class="built_in">addtag4</span>(node, R);   <span class="comment">//直接打标记</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(maxi[node] &lt;= R)&#123;   <span class="comment">//如果小于就不需要继续递归了</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(node, lt, rt);</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Update_Max</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">  <span class="built_in">Update_Max</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">  <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update_Min</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;   <span class="comment">//同理</span></span><br><span class="line">  <span class="keyword">if</span>(maxi[node] &lt; L)&#123;</span><br><span class="line">    <span class="built_in">addtag4</span>(node, L);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(mini[node] &gt;= L)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(node, lt, rt);</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Update_Min</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">  <span class="built_in">Update_Min</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">  <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后取个答案就可以了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Have_ans</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">    a[lt].ans = mini[node];</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(node, lt, rt);</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">Have_ans</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">  <span class="built_in">Have_ans</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">  <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的代码，就不给了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1192B 题解</title>
      <link href="/2022/06/12/CF1192B-%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/06/12/CF1192B-%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>动态维护树上直径问题。</p><span id="more"></span><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>最简单的做法是直接用欧拉序奇怪的性质来求解。</p><p>因为有修改，所以我们很容易想到用数据结构来维护。</p><h3 id="什么是欧拉序"><a href="#什么是欧拉序" class="headerlink" title="什么是欧拉序"></a>什么是欧拉序</h3><p>欧拉序的简单定义是：当 dfs 时，到达 $x$ 时记录一下编号，回溯到达 $x$ 时再记一下编号，到达叶子节点时要记录两个。</p><p>我们可以发现一些有用的性质：</p><ul><li><p>由于每一条边只有递归向下与回溯两种情况经过，还需朝根节点贡献一次，所以欧拉序最多只有 $2 \times n - 1$ 从个数。</p></li><li><p>我们设 $in_x$ 为 $x$ 节点最早出现在欧拉序当中的位置，$out_x$ 为 $x$ 节点最晚出现在欧拉序当中的位置。则 $in_x$ 到 $out_x$ 这一段区间一定是以 $x$ <strong>为根的子树</strong>，从定义中就可以知道。</p></li></ul><p>我们只需要知道这两点，就可以来做题了。</p><h3 id="关于直径"><a href="#关于直径" class="headerlink" title="关于直径"></a>关于直径</h3><p>我们知道，一条直径一定是由一个深度最深的点，到达深度最浅的点，再到达深度第二浅的点。</p><p>那么我们的修改操作可以这么思考（设直径两端点为 $x, y$，$d = lca(x, y)$。）：</p><ul><li><p>修改：利用线段树维护 $dep$。</p></li><li><p>查询：答案为 $dep_x + dep_y - 2 \times dep_d$，我们考虑将它拆成 $(dep_x - 2 \times dep_d) + dep_y$。</p></li></ul><p>我们可以维护一堆值：</p><ul><li><p>$maxd_x$，维护区间深度最大值。</p></li><li><p>$mind_x$，维护区间深度最小值。</p></li><li><p>$lm_x$，维护区间当 $dep_x &gt; dep_y$，$dep_x - 2 \times dep_y$。</p></li><li><p>$mr_x$，同理。</p></li><li><p>$lmr_x$，代表直径长度，具体维护可见以上。</p></li></ul><p>有了这几个东西，我们就可以发现答案就是 $lmr_1$ 了。</p><p>这里给一下 pushup 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">  maxd[node] = <span class="built_in">max</span>(maxd[node &lt;&lt; <span class="number">1</span>], maxd[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  mind[node] = <span class="built_in">min</span>(mind[node &lt;&lt; <span class="number">1</span>], mind[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  lm[node] = <span class="built_in">max</span>(<span class="built_in">max</span>(lm[node &lt;&lt; <span class="number">1</span>], lm[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]), maxd[node &lt;&lt; <span class="number">1</span>] - mind[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] * <span class="number">2</span>);</span><br><span class="line">  mr[node] = <span class="built_in">max</span>(<span class="built_in">max</span>(mr[node &lt;&lt; <span class="number">1</span>], mr[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]), maxd[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] - mind[node &lt;&lt; <span class="number">1</span>] * <span class="number">2</span>);</span><br><span class="line">  lmr[node] = <span class="built_in">max</span>(<span class="built_in">max</span>(lmr[node &lt;&lt; <span class="number">1</span>], lmr[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]), <span class="built_in">max</span>(lm[node &lt;&lt; <span class="number">1</span>] + maxd[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], maxd[node] + mr[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Code：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">8e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q, w;</span><br><span class="line"><span class="type">int</span> W[N], dep[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id[N], cnt, in[N], out[N], mp[N], tid[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Graph | Start</span></span><br><span class="line"><span class="type">int</span> head[N], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">  <span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">  tot++;</span><br><span class="line">  edges[tot].to = v;</span><br><span class="line">  edges[tot].w = w;</span><br><span class="line">  edges[tot].next = head[u];</span><br><span class="line">  mp[tot] = i;</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Graph | End</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Segment tree | Start</span></span><br><span class="line"><span class="type">int</span> maxd[M], mind[M], lm[M], mr[M], lmr[M], tag[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">  maxd[node] = <span class="built_in">max</span>(maxd[node &lt;&lt; <span class="number">1</span>], maxd[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  mind[node] = <span class="built_in">min</span>(mind[node &lt;&lt; <span class="number">1</span>], mind[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]);</span><br><span class="line">  lm[node] = <span class="built_in">max</span>(<span class="built_in">max</span>(lm[node &lt;&lt; <span class="number">1</span>], lm[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]), maxd[node &lt;&lt; <span class="number">1</span>] - mind[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] * <span class="number">2</span>);</span><br><span class="line">  mr[node] = <span class="built_in">max</span>(<span class="built_in">max</span>(mr[node &lt;&lt; <span class="number">1</span>], mr[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]), maxd[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] - mind[node &lt;&lt; <span class="number">1</span>] * <span class="number">2</span>);</span><br><span class="line">  lmr[node] = <span class="built_in">max</span>(<span class="built_in">max</span>(lmr[node &lt;&lt; <span class="number">1</span>], lmr[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]), <span class="built_in">max</span>(lm[node &lt;&lt; <span class="number">1</span>] + maxd[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>], maxd[node] + mr[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  maxd[node] += val;</span><br><span class="line">  mind[node] += val;</span><br><span class="line">  lm[node] -= val;</span><br><span class="line">  mr[node] -= val;</span><br><span class="line">  tag[node] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!tag[node])&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">addtag</span>(node &lt;&lt; <span class="number">1</span>, tag[node]);</span><br><span class="line">  <span class="built_in">addtag</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, tag[node]);</span><br><span class="line">  tag[node] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">    <span class="built_in">addtag</span>(node, dep[id[lt]]);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">  <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y &lt; lt || x &gt; rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    <span class="built_in">addtag</span>(node, val);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(node);</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">  <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Segment tree | End</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">  id[++cnt] = x;</span><br><span class="line">  in[x] = cnt;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(edges[i].to != fa)&#123;</span><br><span class="line">      dep[edges[i].to] = dep[x] + edges[i].w;</span><br><span class="line">      tid[mp[i]] = edges[i].to;</span><br><span class="line">      <span class="built_in">dfs</span>(edges[i].to, x);</span><br><span class="line">      id[++cnt] = x;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  out[x] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; q &gt;&gt; w;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w, i);</span><br><span class="line">    <span class="built_in">add</span>(v, u, w, i);</span><br><span class="line">    W[i] = w;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, cnt);</span><br><span class="line">  <span class="type">int</span> lastans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++)&#123;</span><br><span class="line">    <span class="type">int</span> x, val;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; val;</span><br><span class="line">    x = (x + lastans) % (n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    val = (val + lastans) % w;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, cnt, in[tid[x]], out[tid[x]], val - W[x]);</span><br><span class="line">    W[x] = val;</span><br><span class="line">    lastans = lmr[<span class="number">1</span>];</span><br><span class="line">    cout &lt;&lt; lastans &lt;&lt; endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 树上问题 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈最小生成树</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="最小生成树是什么？"><a href="#最小生成树是什么？" class="headerlink" title="最小生成树是什么？"></a>最小生成树是什么？</h2><p>通俗的说，在一个<strong>无向图</strong>里，要求选 $n - 1$ 条边，使得这 $n$ 个点<strong>连通</strong>，边权和最小的 $n - 1$ 条边就称为最小生成树。</p><span id="more"></span><h2 id="求解最小生成树的算法"><a href="#求解最小生成树的算法" class="headerlink" title="求解最小生成树的算法"></a>求解最小生成树的算法</h2><ol><li>$kruskal$，适用于稀疏图。</li><li>$prim$，适用于稠密图。</li></ol><p>在这里，我们只会讲到 $kruskal$ 算法，<del>因为 $prim$ 没有什么用！</del></p><h2 id="kruskal-算法"><a href="#kruskal-算法" class="headerlink" title="$kruskal$ 算法"></a>$kruskal$ 算法</h2><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p>$kruskal$ 算法是基于贪心的思想，再结合并查集判环而构成的。</p><p>思路：先把所有边存到数组里，然后按照边的大小从小到大排序。此时，我们只要一条一条边利用并查集慢慢合并，当就要有环的时候，再利用并查集判环就可以了。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>存边的数组不要开小，如果点数为 $n$，数组大小<strong>建议</strong>开到 $n^2$。</li><li>并查集数组不要忘记初始化。</li><li><strong>建议</strong>记录边的数量，到达 $n - 1$ 条边时及时跳出，不要浪费时间。</li></ol><h3 id="代码（带注释）"><a href="#代码（带注释）" class="headerlink" title="代码（带注释）"></a>代码（带注释）</h3><p>注：例题为 P3366。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, fa[<span class="number">5005</span>], sum, cnt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">&#125;a[<span class="number">500005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node x, node y)</span></span>&#123;    <span class="comment">//按照权值排序</span></span><br><span class="line"><span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;     <span class="comment">//函数</span></span><br><span class="line"><span class="keyword">if</span>(fa[x] == x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i].u &gt;&gt; a[i].v &gt;&gt; a[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;    <span class="comment">//初始化</span></span><br><span class="line">fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m, cmp);   <span class="comment">//排序</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> e1 = a[i].u, e2 = a[i].v;</span><br><span class="line">e1 = <span class="built_in">find</span>(e1);      <span class="comment">//并查集找祖先</span></span><br><span class="line">e2 = <span class="built_in">find</span>(e2);</span><br><span class="line"><span class="keyword">if</span>(e1 != e2)&#123;</span><br><span class="line">sum += a[i].w;    <span class="comment">//权值和</span></span><br><span class="line">cnt++;      <span class="comment">//边数</span></span><br><span class="line">fa[e2] = e1;    <span class="comment">//合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt == n - <span class="number">1</span>)&#123;    <span class="comment">//如果已选 n - 1 条边</span></span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;orz&quot;</span>;    <span class="comment">//如果不连通</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>此算法最慢的部分在于排序，所以时间复杂度为 $O(mlog_2m)$</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 Trie 树</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88-Trie-%E6%A0%91/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88-Trie-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>Trie 树是一种能够<strong>高效</strong>的存储和使用字符串<strong>集合</strong>的一种东西。</p><span id="more"></span><h2 id="2-手动实现"><a href="#2-手动实现" class="headerlink" title="2. 手动实现"></a>2. 手动实现</h2><p>Trie 树究竟是什么东西呢？让我们通过存储一个字符串集合来直观的了解它。</p><p>已知我们要存储这样的字符串集合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abcd</span><br><span class="line">abfg</span><br><span class="line">aifff</span><br></pre></td></tr></table></figure><p>那么我们一个一个的来存储，第一个存储时，Trie 树是这样的：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ef0nurmj.png" alt=""></p><p>可以看出，Trie 树的存储实质上是建立在一棵树上，我们可以建立一个虚点为整棵树的根节点，然后再建立每个节点。然后建立第二个字符串：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tm9zekqt.png" alt=""></p><p>我们可以发现，<code>abfg</code> 的前面两个字符 <code>ab</code> 跟第一个字符串的和在一起了，这就是它省空间的秘诀：相同的字符可以和在一起。</p><p>然后再加入最后一个字符串，效果如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7dkuv4ds.png" alt=""></p><p>为了以后找字符串是否出现过，我们在字符串结尾的地方打上一个标记，一定要打：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6eapz6jd.png" alt=""></p><p>存储的原理就讲到这，接下来我们讲查询。</p><p>那个 $\color{red}{gou}$ 就有大用处了。</p><p>此时，假设我们查询的字符串为 <code>abfg</code>，我们要查询它是否存在。</p><p>此时我们的查询过程如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/dlqrjehg.png" alt=""></p><p>此时我们到最后<strong>一定</strong>要确定是否有标记，否则当一个查询字符串是现有字符串前缀的时候就会出错。</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><p>这里给出的是一道题的模板，可以学习一下我的 Trie 树风格，别问我，我跟 $yxc$ 学的（$Acwing$ 的大老总）。</p><p>这里以 <a href="https://www.luogu.com.cn/problem/P2580">$\color{black}\texttt{P2580}$</a> 为例，讲一下模板代码。</p><p>插入部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">I</span><span class="params">(string s)</span></span>&#123;    <span class="comment">// s 表示向 Trie 树里插入的字符串</span></span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="type">int</span> u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!son[p][u])&#123;    <span class="comment">// 如果有儿子</span></span><br><span class="line">      son[p][u] = ++idx;    <span class="comment">// son 表示的是儿子节点编号</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = son[p][u];   <span class="comment">// 类似递归</span></span><br><span class="line">  &#125;</span><br><span class="line">  v[p] = <span class="literal">true</span>;     <span class="comment">//v 用来打标记</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询部分：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Q</span><span class="params">(string s)</span></span>&#123;   <span class="comment">// 表示查询的字符串。</span></span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="type">int</span> u = s[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!son[p][u])&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">//如果没有孩子，直接退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = son[p][u];    <span class="comment">// 递归</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v[p];   <span class="comment">// 如果这个字符串有，返回 true，否则返回 false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉很好打。</p><p>作者建议：深度理解代码后，打模板代码 $3$ 到 $5$ 遍，就基本可以掌握了。</p><h1 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h1><p>我们可以发现，在最坏的时候，我们要建立的节点数为所有字符串的长度之和，所以定义 $l$ 为所有字符串的长度之和，那么建立 Trie 树的时间复杂度是 $O(l)$ 的。</p><p>那么同样可以推出，在询问时，时间复杂度是查询的字符串长度（也可能比这个小）。</p><h1 id="例题推荐及讲解"><a href="#例题推荐及讲解" class="headerlink" title="例题推荐及讲解"></a>例题推荐及讲解</h1><p>在这里推荐一道很好的题目：<a href="luogu.com.cn/problem/P5149">$\color{black}\texttt{P5149}$</a>。</p><p>这道题的做法就是，用 Trie 树对排完位的座位进行标号，最后再去求逆序对数列就行了。</p><p>逆序对可以用两个东西求：</p><ol><li><p>树状数组。</p></li><li><p>归并排序。</p></li></ol><p>本博客就讲到这里，拜拜！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> Trie 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈最短路</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="更新目录"><a href="#更新目录" class="headerlink" title="更新目录"></a>更新目录</h2><p>$\text{Update 2022.3.10}$，更新了负环的知识，并且新加了 $\text{Johnson}$ 算法。</p><h2 id="最短路简介"><a href="#最短路简介" class="headerlink" title="最短路简介"></a>最短路简介</h2><p>最短路定义：求出图中的最短路径。</p><span id="more"></span><h2 id="最短路种类"><a href="#最短路种类" class="headerlink" title="最短路种类"></a>最短路种类</h2><p>分为两种：</p><ol><li>单源最短路算法。</li><li>全源最短路算法。</li></ol><p>这里补充一点知识，源点的意思就是起点。</p><p>单源最短路算法，顾名思义，就是求出一个点到另外的所有点的最短路。而全源最短路算法就是求出任意两点之间的最短路。</p><h2 id="求最短路算法"><a href="#求最短路算法" class="headerlink" title="求最短路算法"></a>求最短路算法</h2><p>同样分为两种：</p><p>单源最短路算法：</p><ol><li>$\text{Dijkstra}$。</li><li>$\text{Bellman-ford}$。</li><li>$\text{SPFA}$。</li></ol><p>多源最短路算法：</p><ol><li>$\text{Floyd}$。</li><li>$\text{Johnson}$</li></ol><p>这里只是列出一点时间复杂度优秀且<strong>比较</strong>常用的一点算法，比如像 $\text{dfs}$ 这样的就没有加进来。</p><p>那么，来看看它们是怎么工作的（单源最短路时把 $1$ 看作源点）。</p><h3 id="text-1-Dijkstra"><a href="#text-1-Dijkstra" class="headerlink" title="$\text{1. Dijkstra}$"></a>$\text{1. Dijkstra}$</h3><p>$\text{Dijkstra}$ 的工作原理如下：</p><ol><li><p>将所有点分为白点和黑点，其中白点表示最短路还没有被确定，黑点表示已经确定了。</p></li><li><p>将 $1$ 点标为黑点。</p></li><li><p>把当前最短路最短的黑点连出去的边都松弛，并且都变为黑点。</p></li><li><p>黑点就不需要松弛了。</p></li></ol><p>最后说一下，当边权都是正数或者负数地情况下才能使用该算法，因为两边之和大于第三边。</p><p>所以代码就很容易写了（P3371）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s, dis[<span class="number">100005</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">100005</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> head[<span class="number">100005</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[<span class="number">10000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">edges[tot].to = v;</span><br><span class="line">edges[tot].w = w;</span><br><span class="line">edges[tot].next = head[u];</span><br><span class="line">head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">//为什么这里要循环 n，因为要把 n 个点全部变为黑点</span></span><br><span class="line"><span class="type">int</span> mini = <span class="number">1e9</span>, p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; mini)&#123;</span><br><span class="line">mini = dis[j];</span><br><span class="line">p = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = head[p]; j; j = edges[j].next)&#123;</span><br><span class="line"><span class="type">int</span> nxt = edges[j].to;</span><br><span class="line"><span class="keyword">if</span>(dis[p] + edges[j].w &lt; dis[nxt])&#123;</span><br><span class="line">dis[nxt] = dis[p] + edges[j].w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vis[p] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dijkstra</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>我们发现这里算法的复杂度是 $O(N^2)$ 的，非常的慢，所以考虑优化。</p><p>我们发现，每次都要求最小值，太麻烦了，而每次恰好又只修改最小的那个点的颜色，所以我们想到了什么，$\text{priority_queue}$ 啊，利用它来动态维护最小值就可以了，所以时间成功降到 $O(m\log n)$。</p><p>代码如下（P4779）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">edges[tot].to = v;</span><br><span class="line">edges[tot].w = w;</span><br><span class="line">edges[tot].next = head[u];</span><br><span class="line">head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[s], s));</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">top</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[x])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[x] + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">dis[edges[i].to] = dis[x] + edges[i].w;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[edges[i].to], edges[i].to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dijkstra</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>注意这里要利用 $\text{pair}$ 来维护两个元素，并且还要从小到大排序，所以要取负。</p><h2 id="text-2-Bellman-ford"><a href="#text-2-Bellman-ford" class="headerlink" title="$\text{2. Bellman-ford}$"></a>$\text{2. Bellman-ford}$</h2><p>与其说 $\text{Dijkstra}$ 是一种以点为核心的算法，那么 $\text{Bellman-ford}$ 就是一种以边为核心的算法。</p><p>首先我们想，一条最短路最多只有 $n - 1$ 条边（不考虑负权环），所以每条边最多也就被松弛 $n - 1$ 次，所以 $\text{Bellman-ford}$ 的大体模型就出来了。</p><p>所以代码就出来了（P3371）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u[N], v[N], w[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bellman_ford</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i]= <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[u[j]] + w[j] &lt; dis[v[j]])&#123;</span><br><span class="line">dis[v[j]] = dis[u[j]] + w[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">cin &gt;&gt; u[i] &gt;&gt; v[i] &gt;&gt; w[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bellman_ford</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cout &lt;&lt; (dis[i] == <span class="number">1e9</span> ? <span class="number">2147483647</span> : dis[i]) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>那么它的时间复杂度就是 $O(nm)$，当 $m = n^2$ 时，时间复杂度则是 $O(n^3)$。</p><h2 id="text-3-SPFA"><a href="#text-3-SPFA" class="headerlink" title="$\text{3. SPFA}$"></a>$\text{3. SPFA}$</h2><p>首先声明一点：<del>这是一种已经死了的算法。</del></p><p>$\text{SPFA}$ 是在 $\text{Bellman-ford}$ 的基础之上进行了队列优化。</p><p>我们想，$\text{Bellman-ford}$ 有时候会松弛一点无用的边，那么我们是否可以只松弛有用的边呢？</p><p>答案是肯定的。我们在松弛第一条边时，把点存进队列里，然后把连出去的边继续松弛。</p><p>所以时间复杂度就优化了一点点。</p><p>代码如下（P3371）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">edges[tot].to = v;</span><br><span class="line">edges[tot].w = w;</span><br><span class="line">edges[tot].next = head[u];</span><br><span class="line">head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(s);</span><br><span class="line">vis[s] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[x] + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">dis[edges[i].to] = dis[x] + edges[i].w;</span><br><span class="line"><span class="keyword">if</span>(!vis[edges[i].to])&#123;</span><br><span class="line">q.<span class="built_in">push</span>(edges[i].to);</span><br><span class="line">vis[edges[i].to] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">SPFA</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以时间复杂度就为 $O(km)$，$k$ 是一个很小的常数。</p><p>但是，但是，但是，$\text{SPFA}$ 在最坏情况下仍然可以退化成 $O(nm)$，各种优化的 $\text{hack}$ 请看：<a href="https://www.luogu.com.cn/paste/35b2sh8c">https://www.luogu.com.cn/paste/35b2sh8c</a>。</p><h2 id="附-text-SPFA-判负环"><a href="#附-text-SPFA-判负环" class="headerlink" title="附 - $\text{SPFA}$ 判负环"></a>附 - $\text{SPFA}$ 判负环</h2><p>负环的定义：一个环上的的边权和为负数的环，既可以是有向图，也可以是无向图。</p><p>负环的判定：</p><ol><li><p>从点的角度判断，一个点最多被其余的 $n - 1$ 个点松弛，因此统计每个点的松弛次数，若存在点 $x$ 被松弛 $n - 1$ 次以上，则必然存在负环。</p></li><li><p>从边的角度判断，一条最短路最多包含 $n - 1$ 条边，因此统计起点到点 $x$ 的边数，若存在点 $x$ 到起点的边数在 $n - 1$ 以上，则必然存在负环。</p></li></ol><p>注意事项：</p><ol><li>应用 $\text{SPFA}$ 实现，而不是 $\text{dijkstra}$，因为有负边权。</li><li>如果使用第一种方法，应统计的应该是点 $x$ 被多少<strong>不同的点</strong>松弛。</li></ol><p>第一种方法代码实现（P3385）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m, t;</span><br><span class="line"><span class="type">int</span> dis[N], in[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N * <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">  tot++;</span><br><span class="line">  edges[tot].to = v;</span><br><span class="line">  edges[tot].w = w;</span><br><span class="line">  edges[tot].next = head[u];</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">  queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    dis[i] = <span class="number">1e9</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  vis[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">    <span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line">    vis[x] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line">      <span class="keyword">if</span>(dis[x] + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">        dis[edges[i].to] = dis[x] + edges[i].w;</span><br><span class="line">        <span class="keyword">if</span>(!vis[edges[i].to])&#123;</span><br><span class="line">          q.<span class="built_in">push</span>(edges[i].to);</span><br><span class="line">          vis[edges[i].to] = <span class="literal">true</span>;</span><br><span class="line">          in[edges[i].to]++;</span><br><span class="line">          <span class="keyword">if</span>(in[edges[i].to] &gt; n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; t;</span><br><span class="line">  <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(in, <span class="number">0</span>, <span class="built_in">sizeof</span>(in));</span><br><span class="line">    tot = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">      <span class="type">int</span> u, v, w;</span><br><span class="line">      cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">      <span class="keyword">if</span>(w &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">        <span class="built_in">add</span>(v, u, w);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">add</span>(u, v, w);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; (<span class="built_in">SPFA</span>() ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方法代码实现（题目一样的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line"><span class="type">int</span> dis[N], cnt[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">tot++;</span><br><span class="line">edges[tot].to = v;</span><br><span class="line">edges[tot].w = w;</span><br><span class="line">edges[tot].next = head[u];</span><br><span class="line">head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">2147483647</span>;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">vis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[x] + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">dis[edges[i].to] = dis[x] + edges[i].w;</span><br><span class="line">cnt[edges[i].to] = cnt[x] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(cnt[edges[i].to] &gt;= n)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!vis[edges[i].to])&#123;</span><br><span class="line">q.<span class="built_in">push</span>(edges[i].to);</span><br><span class="line">vis[edges[i].to] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">tot = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="built_in">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line"><span class="type">int</span> u, v, w;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line"><span class="keyword">if</span>(w &gt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line"><span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">add</span>(u, v, w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; (<span class="built_in">spfa</span>() ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对比时间复杂度，第二种方法的速度快一点。</p><h2 id="text-4-Floyd"><a href="#text-4-Floyd" class="headerlink" title="$\text{4. Floyd}$"></a>$\text{4. Floyd}$</h2><p>$\text{Floyd}$ 是一种基于中转点松弛思想的最短路算法。</p><p>思路：</p><p>枚举一个点 $k$，表示一个中转点，再枚举两个点 $i, j$，此时我们可以松弛当 $i$ 到 $j$ 的最短路必须经过 $k$ 时能否更短。</p><p>代码就非常好写了（核心代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[i][k] + dis[k][j] &lt; dis[i][j])&#123;</span><br><span class="line">            dis[i][j] = dis[i][k] + dis[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就不给出完整代码了。</p><h2 id="text-5-Johnson"><a href="#text-5-Johnson" class="headerlink" title="$\text{5. Johnson}$"></a>$\text{5. Johnson}$</h2><p>这是一种能够将负边权转化成正边权从而可以使用 $\text{dijkstra}$ 解决问题的算法。</p><p>步骤：</p><ol><li><p>创建一个虚点 $0$，从 $0$ 向每个点连一条边权为 $0$ 的边。</p></li><li><p>跑一遍 $\text{SPFA}$，求出 $0$ 到每个点的最短路 $h_i$。</p></li><li><p>最关键的一步来了，把 $e_{i, j}$ 这条边加上 $h_i - h_j$。</p></li><li><p>再跑 $n$ 遍 $\text{dijkstra}$。</p></li><li><p>把最短路 $d_{i, j}$ 加上 $-h_i + h_j$。</p></li><li><p>然后就完事了。</p></li></ol><p>这里以模板题为例给出代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> dis[N], d[<span class="number">3005</span>][<span class="number">3005</span>];</span><br><span class="line"><span class="type">int</span> in[N];</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot, head[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> to, w, next;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">  tot++;</span><br><span class="line">  edges[tot].to = v;</span><br><span class="line">  edges[tot].w = w;</span><br><span class="line">  edges[tot].next = head[u];</span><br><span class="line">  head[u] = tot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">h[i] = <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line">h[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[x] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(h[x] + edges[i].w &lt; h[edges[i].to])&#123;</span><br><span class="line">h[edges[i].to] = h[x] + edges[i].w;</span><br><span class="line"><span class="keyword">if</span>(!vis[edges[i].to])&#123;</span><br><span class="line">  in[edges[i].to]++;</span><br><span class="line">  <span class="keyword">if</span>(in[edges[i].to] &gt; n)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">q.<span class="built_in">push</span>(edges[i].to);</span><br><span class="line">vis[edges[i].to] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">  <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">dis[i] = <span class="number">1e9</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(dis[s], s));</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> x = q.<span class="built_in">top</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[x])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis[x] + edges[i].w &lt; dis[edges[i].to])&#123;</span><br><span class="line">dis[edges[i].to] = dis[x] + edges[i].w;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-dis[edges[i].to], edges[i].to));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">SPFA</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = head[i]; j; j = edges[j].next)&#123;</span><br><span class="line">      edges[j].w = edges[j].w + h[i] - h[edges[j].to];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="built_in">dijkstra</span>(i);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(dis[j] != <span class="number">1e9</span>)&#123;</span><br><span class="line">        d[i][j] = dis[j] - h[i] + h[j];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        d[i][j] = <span class="number">1e9</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">      sum += ((<span class="type">long</span> <span class="type">long</span>)j * (<span class="type">long</span> <span class="type">long</span>)d[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是看起来很长，其实有些题目卡 $\text{SPFA}$，并且<strong>有时候</strong>题目也不会刻意卡你 $\text{Bellman-ford}$，所以你可以用 $\text{Bellman-ford}$ 求 $h_i$。</p><h2 id="参与人员"><a href="#参与人员" class="headerlink" title="参与人员"></a>参与人员</h2><p>大力感谢 @<a href="https://www.luogu.com.cn/user/123216">apple365</a> 对本文的贡献与支持。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈单调栈 &amp; 单调队列</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88%E5%8D%95%E8%B0%83%E6%A0%88-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88%E5%8D%95%E8%B0%83%E6%A0%88-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><p>需要掌握用 $\text{STL}$ 和手写的方式来实现栈与队列。</p><p>因为作者的代码风格会变换。</p><h2 id="何为单调栈（队列）"><a href="#何为单调栈（队列）" class="headerlink" title="何为单调栈（队列）"></a>何为单调栈（队列）</h2><p>指的是当栈（队列）里的元素有单调性时的栈（队列）。</p><span id="more"></span><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>可能你会觉得单调栈很难理解，其实只要动手画画图就可以了。</p><p>我们手动画一个图（以 P5788 为例）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/u2tylmdw.png" alt=""></p><p>那么我们循环到第一个元素时，由于栈里面没有比他小的数，所以直接弹入：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6m5pbbm4.png" alt=""></p><p>此时我们栈里的元素是一个结构体 $\text{Node}$，第一个数表示元素大小，第二个表示位置。</p><p>那么我们再循环到第二个数，由于栈里没有比它要小的数所以此时我们弹出 $a_1$，并将 $a_1$ 的答案值改为 $2$（因为是记录位置）：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/szb6m3da.png" alt=""></p><p>此时我们循环到 $a_3$ 了发现比栈里的元素都要小，直接弹入：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nhg36cxn.png" alt=""></p><p>那么，现在循环到 $a_4$，我们发现 $a_4 &gt; a_3$ 所以将 $a_3$ 弹出，并将 $a_3$ 的答案值设为 $4$：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vnkd8x83.png" alt=""></p><p>到了最后一个元素 $a_5$ 了，此时我们发现 $a_5 &gt; a_4$ 并且 $a_5 &gt; a_2$，所以把 $a_4$ 和 $a_2$ 弹出且将答案都修改为 $5$：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/hprd75fj.png" alt=""></p><p>此时我们发现我们的答案序列是 $2\ 5\ 4\ 5\ 0$，也就是对的。</p><p>我们发现，在单调栈中的元素在任意时刻都是满足单调递减的，从而实现查找最近的元素。</p><p>随后我们来分析时间复杂度：由于每个元素只会出队和入队各一次，所以时间复杂度为 $O(2n)$，也就是 $O(n)$ 的。可以看出单调栈的时间复杂度十分优秀。</p><p>P5788 的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e6</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N], d[N];</span><br><span class="line"></span><br><span class="line">stack&lt;<span class="type">int</span>&gt; stk1, stk2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stk1.<span class="built_in">empty</span>() &amp;&amp; a[i] &gt; stk1.<span class="built_in">top</span>())&#123;</span><br><span class="line">      d[stk2.<span class="built_in">top</span>()] = i;</span><br><span class="line">      stk1.<span class="built_in">pop</span>();</span><br><span class="line">      stk2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stk1.<span class="built_in">push</span>(a[i]);</span><br><span class="line">    stk2.<span class="built_in">push</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cout &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有什么问题可以私信 _Alexande_。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈分块</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88%E5%88%86%E5%9D%97/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88%E5%88%86%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>本博客的 $\sqrt{n}$ 全部定义为向下取整。</p><h2 id="分块是什么？"><a href="#分块是什么？" class="headerlink" title="分块是什么？"></a>分块是什么？</h2><p>分块是一种优雅的暴力。</p><span id="more"></span><h2 id="分块的思想"><a href="#分块的思想" class="headerlink" title="分块的思想"></a>分块的思想</h2><p>分块，就是把长度为 $n$ 的数列分成几个块（这里我们定义分成 $\sqrt{n}$ 个块），然后对于每个块分段解决，其<strong>普通</strong>时间复杂度（在块长为 $\sqrt{n}$ 的情况下）为 $m \sqrt{n}$，$m$ 为<strong>区间</strong>操作的个数。</p><p>首先我们要理解分块是如何分的，我们首先造一组样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 4 2 8 4 6 2 9 7 3</span><br></pre></td></tr></table></figure><p>那么如果分成 $\sqrt{n}$ 个块的情况下，应该是这样分的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 4 2 | 8 4 6 | 2 9 7 3</span><br></pre></td></tr></table></figure><p>由于我们要严格保证有 $\sqrt{n}$ 个块，所以可能在最后会有一段不足 $\sqrt{n}$ 的数（就比如说 $3$），所以我们把这段数接在最后面。</p><p>我们定义 $L_i$ 为第 $i$ 个块的最左端，$R_i$ 为第 $i$ 个块的最右端，则 $L_i$ 为 $(i - 1) \times \sqrt{n} + 1$，$R_i$ 为 $i \times \sqrt{n}$。</p><p>那么我们还要维护一个数组 $pos_i$，表示下标 $i$ 所在的块。我们只需要枚举每个块的左端点和右端点，直接赋值即可。</p><p>下面是分块的初始化代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] = (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] = i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">pos[j] = i;</span><br><span class="line"><span class="comment">//     </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的初始化是基本操作，是分块之前必须做的预处理，接下来我们看如何操作。</p><p>由于 hzwer 大佬的数列分块入门九题对分块造成了非常大的影响，所以这里就用这九道题来讲（这九道题可以在 LOJ 上自己找）。</p><h2 id="数列分块入门-1"><a href="#数列分块入门-1" class="headerlink" title="数列分块入门 $1$"></a>数列分块入门 $1$</h2><p>我们还是分 $\sqrt{n}$ 个块，在修改时，我们维护一个数组 $tag$，表示加法的标记，然后对于加的整块（完整的块）直接加 $tag$ 即可，而对于两端不完整的块（也就是修改左端点 $lt$ 和修改右端点 $rt$ 的所在块）直接暴力加即可。</p><p>对于查询，只需输出 $tag_{pos_i} + a_i$ 即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> L[N], R[N], pos[N];</span><br><span class="line"><span class="type">int</span> tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">tag[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] = (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] = i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">pos[j] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> op, l, r, c;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">update</span>(l, r, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; a[r] + tag[pos[r]] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="数列分块入门-2"><a href="#数列分块入门-2" class="headerlink" title="数列分块入门 $2$"></a>数列分块入门 $2$</h2><p>这道题的难点就在于查询小于 $c$ 的数，首先我们可以对于每一个块，用一个 $vector$ 数组来存，然后对于每个块的 $vector$ 排个序，所以，在查询时，我们就可以直接对于每个块使用 $lower_bound$ 来求了。</p><p>而对于修改，由于散块的大小顺序可能会被改变，所以重新排一遍序就可以了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num[N];</span><br><span class="line"><span class="type">int</span> L[N], R[N], pos[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resort</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">num[x].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[x]; i &lt;= R[x]; i++)&#123;</span><br><span class="line">num[x].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(num[x].<span class="built_in">begin</span>(), num[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">tag[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[x] &lt; val)&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[x] &lt; val)&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">ans += <span class="built_in">lower_bound</span>(num[i].<span class="built_in">begin</span>(), num[i].<span class="built_in">end</span>(), val - tag[i]) - num[i].<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[y] &lt; val)&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] += (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] += i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">pos[j] = i;</span><br><span class="line">num[i].<span class="built_in">push_back</span>(a[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(num[i].<span class="built_in">begin</span>(), num[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> op, l, r, c;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">update</span>(l, r, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(l, r, c * c) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数列分块入门-3"><a href="#数列分块入门-3" class="headerlink" title="数列分块入门 $3$"></a>数列分块入门 $3$</h2><p>这道题在 $2$ 的基础上改一点即可，因为我们知道了小于 $c$ 的个数，所以在整块内小于 $c$ 最大的值就是 $a_i$ 加上块所在的 $tag$，此时只要判断有没有小于 $c$ 的数就可以了。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; num[N];</span><br><span class="line"><span class="type">int</span> L[N], R[N], pos[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">resort</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">num[x].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[x]; i &lt;= R[x]; i++)&#123;</span><br><span class="line">num[x].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(num[x].<span class="built_in">begin</span>(), num[x].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">tag[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">resort</span>(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[x] &lt; val)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, a[i] + tag[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[x] &lt; val)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, a[i] + tag[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(val - tag[i] &lt;= num[i][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, num[i][<span class="built_in">lower_bound</span>(num[i].<span class="built_in">begin</span>(), num[i].<span class="built_in">end</span>(), val - tag[i]) - num[i].<span class="built_in">begin</span>() - <span class="number">1</span>] + tag[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i] + tag[y] &lt; val)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, a[i] + tag[y]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] += (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] += i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">pos[j] = i;</span><br><span class="line">num[i].<span class="built_in">push_back</span>(a[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(num[i].<span class="built_in">begin</span>(), num[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> op, l, r, c;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">update</span>(l, r, c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(l, r, c) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数列分块入门-4"><a href="#数列分块入门-4" class="headerlink" title="数列分块入门 $4$"></a>数列分块入门 $4$</h2><p>在 $1$ 的基础上增加了区间查询，直接注意在计算每个块时加上 $tag$ 即可。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos[N], L[N], R[N], sum[N], tag[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line">sum[x] += (rt - lt + <span class="number">1</span>) * val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line">sum[x] += (R[x] - lt + <span class="number">1</span>) * val;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">tag[i] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">a[i] += val;</span><br><span class="line">&#125;</span><br><span class="line">sum[y] += (rt - L[y] + <span class="number">1</span>) * val;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> mod)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">ans += tag[x];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">ans %= mod;</span><br><span class="line">ans += tag[x];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">ans %= mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">ans += sum[i];</span><br><span class="line">ans %= mod;</span><br><span class="line">ans += (R[i] - L[i] + <span class="number">1</span>) % mod * tag[i] % mod;</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">ans %= mod;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">ans %= mod;</span><br><span class="line">ans += tag[y];</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line">ans %= mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] = (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] = i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">sum[i] += a[j];</span><br><span class="line">pos[j] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line">cin &gt;&gt; op;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="type">int</span> x, y, k;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line"><span class="built_in">update</span>(x, y, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> x, y, k;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(x, y, k + <span class="number">1</span>) % (k + <span class="number">1</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数列分块入门-5"><a href="#数列分块入门-5" class="headerlink" title="数列分块入门 $5$"></a>数列分块入门 $5$</h2><p>由于开方操作很不好计算，所以我们可以从另一个角度取想。</p><p>我们想，当一个块里的数全部都是 $\le 1$ 时，我们就没有必要算下去了，由于开方最多开 $4$ 次才变成 $1$，所以时间复杂度显然没有问题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pos[N], L[N], R[N], sum[N];</span><br><span class="line"><span class="type">bool</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">sum[x] -= a[i];</span><br><span class="line">a[i] = <span class="built_in">sqrt</span>(a[i]);</span><br><span class="line">sum[x] += a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">sum[x] -= a[i];</span><br><span class="line">a[i] = <span class="built_in">sqrt</span>(a[i]);</span><br><span class="line">sum[x] += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!f[i])&#123;</span><br><span class="line">f[i] = <span class="literal">true</span>;</span><br><span class="line">sum[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">a[j] = <span class="built_in">sqrt</span>(a[j]);</span><br><span class="line">sum[i] += a[j];</span><br><span class="line"><span class="keyword">if</span>(a[j] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">f[i] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">sum[y] -= a[i];</span><br><span class="line">a[i] = <span class="built_in">sqrt</span>(a[i]);</span><br><span class="line">sum[y] += a[i]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = pos[lt], y = pos[rt];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x == y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= rt; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = lt; i &lt;= R[x]; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = x + <span class="number">1</span>; i &lt; y; i++)&#123;</span><br><span class="line">ans += sum[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = L[y]; i &lt;= rt; i++)&#123;</span><br><span class="line">ans += a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sq = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line">L[i] = (i - <span class="number">1</span>) * sq + <span class="number">1</span>;</span><br><span class="line">R[i] = i * sq;</span><br><span class="line">&#125;</span><br><span class="line">R[sq] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sq; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = L[i]; j &lt;= R[i]; j++)&#123;</span><br><span class="line">pos[j] = i;</span><br><span class="line">sum[i] += a[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="type">int</span> op, l, r, c;</span><br><span class="line">cin &gt;&gt; op &gt;&gt; l &gt;&gt; r &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">update</span>(l, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(l, r) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈 ST 表</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88-ST-%E8%A1%A8/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88-ST-%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="text-ST-表是什么"><a href="#text-ST-表是什么" class="headerlink" title="$\text{ST}$ 表是什么"></a>$\text{ST}$ 表是什么</h2><p>$\text{ST}$ 表是解决 RMQ（区间最值问题）的一种可靠工具。</p><p>它能够维护静态区间最值，并且时间复杂度是 $O(n\log n)$，常数极小，<del>相比线段树，不知道好到哪里去了。</del></p><span id="more"></span><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>$\text{ST}$ 表利用倍增的思想来求区间最值。</p><p>首先我们可以令 $f_{i, j}$ 表示从位置 $i$ 开始的后面一共 $2^j$ 个数的最大值，注意，这 $2^j$ 个数包括 $i$。</p><p>所以我们可以得出以下初始结论：$f_{i, 0}$。</p><p>那么我们就可以轻而易举的推出 $f<em>{i, j}$ 是由哪两个区间推出来的了。首先我们知道：$2^j = 2^{j - 1} \times 2^{j - 1}$，那么当前区间长为 $2^j$ 的区间就应该为两个长度为 $2^{j - 1}$ 的区间取 $\max$ 的来。这样思考，那么 $f</em>{i, j} = \max(f<em>{i, j - 1}, f</em>{i + 2^{j - 1}, j - 1})$。此时的 $i + 2^{j - 1}$ 就是第二个长度为 $2^{j - 1}$ 的区间的起始点。</p><p>这样来看，$ST$ 表的 $f$ 数组更类似与 $dp$ 的转移，而我们的 $j$ 是递减的，所以我们应该在第一层循环枚举 $j$，那么循环的边界就肯定是 $\log n$ 的。然后我们看对于 $i$ 的循环，对于 $i$ 的循环，应该有两个条件：</p><ol><li><p>$i \le n$。</p></li><li><p>$j + 2^j - 1 \le n$。</p></li></ol><p>这个式子我们是可以轻而易举的推出来的。但是，作者想说的是，虽然式子推出来了，但是式子里有许多 $2^j$ 和 $\log j$，所以我们可以用一个数组存下来，<del>卡常数</del>。</p><p>接下来是预处理代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">logg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">  bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">  logg[i] = logg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= logg[n]; i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; j + bin[i] - <span class="number">1</span> &lt;= n; j++)&#123;</span><br><span class="line">    f[j][i] = <span class="built_in">max</span>(f[j][i - <span class="number">1</span>], f[j + bin[i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里并没有放上初始化 $f_{i, 0}$ 的代码。</p><p>然后我们如何查询呢？首先我们要知道一点：对于长度为 $x$ 的区间，设 $k = \log(x)$，则这段区间肯定可以被两端长度为 $2^k$ 的区间覆盖起来。</p><p>知道了这个结论，就很简单了吧！接下来直接放代码了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[N][<span class="number">21</span>], logg[N], bin[<span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">      f = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    x = x * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span>();</span><br><span class="line">  m = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    f[i][<span class="number">0</span>] = <span class="built_in">read</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  bin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  logg[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)&#123;</span><br><span class="line">    bin[i] = bin[i - <span class="number">1</span>] &lt;&lt; <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    logg[i] = logg[i &gt;&gt; <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= logg[n]; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n &amp;&amp; j + bin[i] - <span class="number">1</span> &lt;= n; j++)&#123;</span><br><span class="line">      f[j][i] = <span class="built_in">max</span>(f[j][i - <span class="number">1</span>], f[j + bin[i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    x = <span class="built_in">read</span>();</span><br><span class="line">    y = <span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> len = y - x + <span class="number">1</span>, tmp = logg[len];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(f[x][tmp], f[y - bin[tmp] + <span class="number">1</span>][tmp]) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> ST 表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈树链剖分</title>
      <link href="/2022/06/11/%E6%B5%85%E8%B0%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/2022/06/11/%E6%B5%85%E8%B0%88%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<h2 id="树链剖分是什么？"><a href="#树链剖分是什么？" class="headerlink" title="树链剖分是什么？"></a>树链剖分是什么？</h2><p>树链剖分，简称树剖，是一种<del>卡常小技巧</del>，可以解决树上差分和 LCA 揉搓在一起的问题。</p><span id="more"></span><h2 id="树链剖分的思想"><a href="#树链剖分的思想" class="headerlink" title="树链剖分的思想"></a>树链剖分的思想</h2><p>我们需要接触以下名词：</p><ul><li><p>重儿子：指一个节点的所有儿子中所在子树节点最多的那个儿子。</p></li><li><p>轻儿子：指除重儿子外其余的节点。</p></li><li><p>重边：指任意两个重儿子相连的边（注意，只是一条边）。</p></li><li><p>轻边：指除重边外其余的边。</p></li><li><p>重链：指一条全是由重边组成的路径，其顶部是轻儿子。</p></li></ul><p>我从 NaCly_Fish 大佬的博客下搬了一张图片：</p><p><img src="https://cdn.luogu.com.cn/upload/pic/45367.png" alt=""></p><p>从这里，我们可以清晰的看出，哪些边是哪些属性（画红色的边是重边）。</p><p>由于需要预处理出这些信息并且后面查询时需要在重链上面跳，所以我们需要一些信息（这里默认 $1$ 节点是根节点）：</p><ul><li><p>$dep_i$，指 $i$ 节点的深度。</p></li><li><p>$size_i$，指 $i$ 节点所在的子树大小。</p></li><li><p>$son_i$，指 $i$ 节点的重儿子。</p></li><li><p>$fa_i$，指 $i$ 节点的父亲。</p></li><li><p>$top_i$，指 $i$ 节点所在的重链顶点（为什么需要这个呢？因为我们查询的时候需要跳重链！）</p></li><li><p>$id_i$，指 $i$ 节点的 $\text{dfs}$ 序。</p></li></ul><p>然后我们分批进行预处理，为什么呢？因为有些信息是要通过某些信息才能得来的！</p><p>第一次预处理 $\text{dfs1}$，我们求出前四个信息（这应该难不倒你！）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">  fa[x] = f;</span><br><span class="line">  size[x] = <span class="number">1</span>;</span><br><span class="line">  dep[x] = dep[f] + <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span> maxi = <span class="number">-1e9</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(edges[i].to != f)&#123;</span><br><span class="line">      <span class="built_in">dfs1</span>(edges[i].to, x);</span><br><span class="line">      size[x] += size[edges[i].to];</span><br><span class="line">      <span class="keyword">if</span>(size[edges[i].to] &gt; maxi)&#123;</span><br><span class="line">        maxi = size[edges[i].to];</span><br><span class="line">        son[x] = edges[i].to;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到了第二次预处理时，我们需要维护一个线段树，以 $id$ 为下标插入，到了后面会说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">  top[x] = t;</span><br><span class="line">  id[x] = ++sum;</span><br><span class="line">  <span class="keyword">if</span>(a[x])&#123;   <span class="comment">//这里是个优化，如果是 0 就不要加了</span></span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x], a[x]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!son[x])&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">dfs2</span>(son[x], t);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = head[x]; i; i = edges[i].next)&#123;</span><br><span class="line">    <span class="keyword">if</span>(edges[i].to != son[x] &amp;&amp; edges[i].to != fa[x])&#123;</span><br><span class="line">      <span class="built_in">dfs2</span>(edges[i].to, edges[i].to);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，一颗子树内的所有 $id$ 都是连续的，一条重链上的 $id$ 也是连续的。</p><p>所以加整条重链就就可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]);</span><br></pre></td></tr></table></figure><p>此时我们就可以这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = fa[top[x]];</span><br></pre></td></tr></table></figure><p>这样就直接跳到重链的头了。</p><p>所以我们不断这样跳，第一个操作就完成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  val %= p;</span><br><span class="line">  <span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])&#123;</span><br><span class="line">      <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], val);</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个操作也是一样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(top[x] != top[y])&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[top[x]] &lt; dep[top[y]])&#123;</span><br><span class="line">      <span class="built_in">swap</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x]);</span><br><span class="line">    ans %= p;</span><br><span class="line">    x = fa[top[x]];</span><br><span class="line">  &#125;</span><br><span class="line">  ans += <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y]);</span><br><span class="line">  <span class="keyword">return</span> ans % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 $3, 4$ 个操作都是针对于子树的，又由于子树的 $id$ 是连续的，所以我们可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Update2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  val %= p;</span><br><span class="line">  <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x] + size[x] - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x] + size[x] - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>然后你就学会了树链剖分。</del> 至于线段树，baidu 是个好东西。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树状数组 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎来到 _Alexande_ 的博客</title>
      <link href="/2022/06/11/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0-Alexande-%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/06/11/%E6%AC%A2%E8%BF%8E%E6%9D%A5%E5%88%B0-Alexande-%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="关于本人"><a href="#关于本人" class="headerlink" title="关于本人"></a>关于本人</h2><ul><li><p>本人是口胡选手。</p></li><li><p>本人目前是 xxs。</p></li><li><p>本人目前还在摸鱼，没有搞 whk。</p></li></ul><h2 id="关于-blog"><a href="#关于-blog" class="headerlink" title="关于 blog"></a>关于 blog</h2><p>首先，本 blog 是置顶 blog，所以前面会有 “[置顶]”，前面带有 “[算法]”的 blog 仅指<strong>本人的学习笔记，并没有算法和数据结构之分。</strong></p><p>还有就是，你可以在最后看见一些奇怪的东西，如果你不知道怎么用，可以尝试按下 F12，打开 “Console”，然后 Ctrl + v 再按 Enter。</p><p>如果你希望在 blog 中寻找一些东西，你可以按下 F3 并输入你想搜索的东西。</p><p>然后，如果你发现有些东西写错了，可以私信 _Alexande_。</p><p>最后，希望你快乐的阅读本蒟蒻的 blog。</p><h2 id="关于以上"><a href="#关于以上" class="headerlink" title="关于以上"></a>关于以上</h2><p>以上介绍为洛谷搬运而来，所以有些许不准确！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈树状数组</title>
      <link href="/2022/06/10/%E6%B5%85%E8%B0%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2022/06/10/%E6%B5%85%E8%B0%88%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li><p>了解二进制以及性质。</p></li><li><p>了解计算机中的原码，反码，补码。</p></li></ol><p>这些是学会树状数组的必备功，如果不会可以上网搜一下（<del>反正不会耽误你多少时间</del>）。</p><span id="more"></span><h2 id="树状数组是什么？"><a href="#树状数组是什么？" class="headerlink" title="树状数组是什么？"></a>树状数组是什么？</h2><ul><li><p>树状数组是一种可以高效（相比于线段树常数小一点）解决单点查询，区间修改或者单点修改，区间查询。</p></li><li><p>树状数组是一种利用二进制拆分思想的高级数据结构</p></li></ul><p>以上是它的简介。</p><h2 id="树状数组的思想"><a href="#树状数组的思想" class="headerlink" title="树状数组的思想"></a>树状数组的思想</h2><p>树状数组（Binary Indexed Tree），是一种数据结构，我们还是通过一个题目来了解它：P3374。</p><p>我们又来想暴力啦！</p><ol><li><p>暴力，时间复杂度 $O(N^2)$。</p></li><li><p>前缀和，时间复杂度 $O(N^2)$。</p></li><li><p><del>线段树，可以过但代码太长。</del></p></li></ol><p>现在假设你不会写线段树，那么我们就需要树状数组这种数据结构。</p><p><strong>注意，下面的部分建议读者反复观看。</strong></p><p>树状数组的主要思想就是二进制拆分，我们来看看是怎么个拆法。</p><p>首先假设我们的序列为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">1 0 2 1 2 3 0 3 0 5 3 2 1</span><br></pre></td></tr></table></figure><p>首先我们将 $13$，也就是所谓的 $n$ 进行转二进制，得 $1101$，我们发现这个二进制数里有三个 $1$，也就是说 $13 = 2^3 + 2^2 + 2^0$，这里利用倍增得思想，从大到小排，听不懂也没关系。</p><p>所以我们可以将整个序列 $13$ 个数分成以下几个部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">1 0 2 1 2 3 0 3 | 0 5 3 2 | 1</span><br></pre></td></tr></table></figure><p>| 为分隔符，所以我们发现每个部分得长度对应这这些二进制 $1$ 的数值，由于一个数的二进制拆分是唯一的，所以这些部分也都是唯一的。我们可以用 $tree$ 数组来存放每个部分的数值和，现在我们规定以下 $tree$ 的存储方式：</p><p>$tree<em>8$ 为第一部分的数值和，$tree</em>{12}$ 为第二部分的数值和，$tree_{13}$ 为第三部分的数值和。</p><p>为什么这么定义呢？我们可以发现，$8$ 正好就是 $2^3$，$12$ 正好就是 $2^3 + 2^2$，而 $13$ 又正好就是 $2^3 + 2^2 + 2^0$。我们发现，每个部分记录数值和的 $tree$ 下标都是不断以 $1$ 的数值叠加的。</p><h3 id="最初的最初（-text-lowbit-）"><a href="#最初的最初（-text-lowbit-）" class="headerlink" title="最初的最初（$\text{lowbit}$）"></a>最初的最初（$\text{lowbit}$）</h3><p>我们该怎样计算这些 $tree$ 的下标呢？这里我们就需要用到函数 $\text{lowbit}$，意思是最低位。它表示的是一个数的二进制数的最低位的 $1$ 以及跟后面的 $0$ 所组成的数。就比如说 $13$ 的二进制数 $1101$ 的 $\text{lowbit}$ 就是二进制数 $1$，也就是十进制数 $1$。</p><p>那么我们发现，第三个部分 $tree$ 的下标是 $13$，也就是 $n$，而第二个部分 $tree$ 的下标就是 $13 - \text{lowbit(13)}$，也就是 $12$，继续下去，第一个部分 $tree$ 的下标就是 $12 - \text{lowbit(12)}$，也就是 $8$!</p><p>实际上，这样的事情并不是巧合，而是从 $tree$ 的下标的本身规律来定义的 $\text{lowbit}$。</p><p>现在我们考虑 $\text{lowbit}$ 如何计算，难道就真的要二进制拆分吗？其实不需要，我们发现，一个数的二进制与这个二进制数的取反加 $1$ 相互进行 $\&amp;$ 操作就正好是这个数的 $\text{lowbit}$！具体原因可以上网搜，又由于这个二进制数的取反加 $1$ 正是这个数的补码（$x$ 的补码等于 $-x$），所以 $\text{lowbit}(x) = x \&amp; -x$！</p><h3 id="关于一些关系问题"><a href="#关于一些关系问题" class="headerlink" title="关于一些关系问题"></a>关于一些关系问题</h3><p>比如说要查询 $1$ ~ $13$，那么最初加上 $tree_{13}$ 之后又要加上什么呢？我们应该是要加上 $tree_8$，如果你仔细思考的话，就知道 $8 = 13 - \text{lowbit}(13)$，那么这个部分的后面那个部分的下标就是 $x + \text{lowbit}(x)$，前面部分的下标就是 $x - \text{lowbit}(x)$。</p><h3 id="更新（-text-update-）"><a href="#更新（-text-update-）" class="headerlink" title="更新（$\text{update}$）"></a>更新（$\text{update}$）</h3><p>由于更改一个点只会讲后面部分的节点前缀和给更改，所以应该是不断 $ + \text{lowbit}(x)$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">tree[x] += val;</span><br><span class="line">x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询（-text-query-）"><a href="#查询（-text-query-）" class="headerlink" title="查询（$\text{query}$）"></a>查询（$\text{query}$）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">sum += tree[x];</span><br><span class="line">x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> tree[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line">sum += tree[x];</span><br><span class="line">x -= <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x &lt;= n)&#123;</span><br><span class="line">tree[x] += val;</span><br><span class="line">x += <span class="built_in">lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="built_in">update</span>(i, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> op;</span><br><span class="line">cin &gt;&gt; op;</span><br><span class="line"><span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> x, k;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line"><span class="built_in">update</span>(x, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; <span class="built_in">query</span>(y) - <span class="built_in">query</span>(x - <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树状数组可以解决什么问题？"><a href="#树状数组可以解决什么问题？" class="headerlink" title="树状数组可以解决什么问题？"></a>树状数组可以解决什么问题？</h2><p>树状数组擅长解决这两类问题：</p><ol><li><p>逆序对。</p></li><li><p>二维偏序。</p></li></ol><h3 id="逆序对"><a href="#逆序对" class="headerlink" title="逆序对"></a>逆序对</h3><p>这里有两种方法。</p><h4 id="1-离散化"><a href="#1-离散化" class="headerlink" title="1. 离散化"></a>1. 离散化</h4><p>我们可以讲以权值建树状数组，然后将值进行 $+ 1$ 操作，然后直接前缀和一下就可以了</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="type">int</span> p;</span><br><span class="line">&#125;a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, ans;</span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = x; i &lt;= n; i += <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">    d[i] += c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i))&#123;</span><br><span class="line">    sum += d[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Node x, Node y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x.x == y.x)&#123;</span><br><span class="line">    <span class="keyword">return</span> x.p &lt; y.p;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x.x &lt; y.x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i].x;</span><br><span class="line">    a[i].p = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + n, cmp);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    vis[a[i].p] = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    <span class="built_in">update</span>(vis[i], <span class="number">1</span>);</span><br><span class="line">    ans += (i - <span class="built_in">query</span>(vis[i]));</span><br><span class="line">  &#125;</span><br><span class="line">  cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该很简单。</p><h4 id="2-排序"><a href="#2-排序" class="headerlink" title="2. 排序"></a>2. 排序</h4><p>首先我们按照下标建树状数组，然后我们把 $a$ 排序（升序），每次查询前缀和，然后将本身 $ + 1$ 就行了。</p><p><del>代码没有</del></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈线段树</title>
      <link href="/2022/06/08/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2022/06/08/%E6%B5%85%E8%B0%88%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ol><li>了解位运算（为线段树优化做铺垫）。</li><li>了解堆。</li><li>了解树。</li></ol><p>如果您还没有学完，就可以不用看下面的内容了。</p><span id="more"></span><h2 id="线段树是什么？"><a href="#线段树是什么？" class="headerlink" title="线段树是什么？"></a>线段树是什么？</h2><ul><li><p>线段树是一种可以解决区间问题的利器。</p></li><li><p>线段树是一种高级数据结构。</p></li><li><p>线段树是一种<strong>二叉搜索树</strong>（来源于网上）。</p></li></ul><p>只不过以上这些都是介绍，其实真正的线段树并没有那么恐怖。</p><h2 id="线段树的思想"><a href="#线段树的思想" class="headerlink" title="线段树的思想"></a>线段树的思想</h2><p>线段树（segment tree），又名区间树。我们可以通过一个题目来直观的了解它：P3372。</p><p>我们按照常规思路想：</p><ol><li><p>暴力，时间复杂度 $O(N^2)$。</p></li><li><p>前缀和，由于有修改操作，所以时间复杂度为 $O(N^2)$。</p></li></ol><p>这个复杂度是我们不可接受的，所以我们用线段树来解决这个问题。</p><p>我们假设原来的序列为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 9 3 1 2 5 2 2</span><br></pre></td></tr></table></figure><p>线段树，顾名思义，首先要建一棵<strong>二叉</strong>树：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8cut34o7.png" alt=""></p><p>一定要注意是二叉树。</p><p>这棵树按照堆式存储来编号，一共有 $15$ 个节点。</p><p>然后我们赋予它每个节点一点值，并且把值记录为 $tree$：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9wqpjw8f.png" alt=""></p><p>每个节点旁边的一个区间代表这个节点的值是这个区间的和，例如 $tree_5 = 4$。</p><p>那么区间又有什么特殊的性质呢？假设一个节点所代表的区间是 $[l, r]$，那么它的两个子节点的区间就分别是 $[l, (l + r &gt;&gt; 1)]$，$[(l + r &gt;&gt; 1), r]$。就是分治的思想。</p><p>线段树的意义就讲完了，接下来将如何实现。</p><h3 id="最初的最初（-text-pushup-）"><a href="#最初的最初（-text-pushup-）" class="headerlink" title="最初的最初（$\text{pushup}$）"></a>最初的最初（$\text{pushup}$）</h3><p>$\text{pushup}$ 是一个函数，表示向上更新的意思，每次可以更新节点 $cur$ 的值。</p><p>$\text{pushup}$ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[cur] = tree[cur &lt;&lt; <span class="number">1</span>] + tree[(cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>];   <span class="comment">//更新</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是一个回溯操作。</p><h3 id="建树（-text-build-）"><a href="#建树（-text-build-）" class="headerlink" title="建树（$\text{build}$）"></a>建树（$\text{build}$）</h3><p>这里非常简单，就是不断的分治/递归下去，最后再用 $\text{pushup}$ 更新就可以了。</p><p>注意，到了叶子节点可以直接返回值。</p><p>$\text{build}$ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt)</span> <span class="comment">//cur 为树上节点，管辖 [lt, rt] 的数列区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lt == rt)   <span class="comment">//递归到叶子节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[cur] = a[lt];</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid);   <span class="comment">//继续分治/递归</span></span><br><span class="line">    <span class="built_in">build</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">    <span class="built_in">pushup</span>(cur);  <span class="comment">//向上传递结果</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里时间复杂度为 $O(4N)$。</p><h3 id="查询（-text-query-）"><a href="#查询（-text-query-）" class="headerlink" title="查询（$\text{query}$）"></a>查询（$\text{query}$）</h3><p>举个例子。</p><p>就比如说查询区间 $[3, 8]$，我们首先把问题看到节点 $1$。节点 $1$ 说我管得范围太大了，得让我的两个儿子来解决。然后节点 $2$ 说，我也解决不了，又得给我的两个儿子解决。节点 $4$ 说这事跟我没关系，但节点 $5$ 说我正好就是问题中的一部分，可以解决。再来看节点 $3$，它说我也可以正好解决。所以询问的结果就是 $tree_5 + tree_3$。</p><p>从上述讲话中来看，其实就是不断的传儿子，只要在区间内就返回。</p><p>画图表示一下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/84vih07k.png" alt=""></p><p>所以查询操作到的每个区间就只有三种选择：</p><ol><li>询问的区间 $[x, y]$ 和这个节点所覆盖的区间 $[lt, rt]$ 根本没有关系。</li></ol><p>图示如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8243u4xu.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/qva96nkw.png" alt=""></p><ol><li>询问的区间 $[x, y]$ 和这个节点所覆盖的区间 $[lt, rt]$ 是完全包含的关系。</li></ol><p>图示如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/oy58z9in.png" alt=""></p><ol><li>问的区间 $[x, y]$ 和这个节点所覆盖的区间 $[lt, rt]$ 是部分包含的关系。</li></ol><p>图示如下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8exetcrs.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xqsftoji.png" alt=""></p><p>此时我们只有当区间是 $3$ 的情形时才下传。</p><p>所以我们的代码就可以这么写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">//cur 代表当前的节点，lt, rt 表示这个节点所管辖的区间，x, y 表示我要询问的区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; rt || y &lt; lt) <span class="comment">//都已经没有关系了，直接返回 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y) <span class="comment">//是 [x, y] 的一部分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;   <span class="comment">//向左右儿子请求答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid, x, y) + <span class="built_in">query</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里时间复杂度是 $O(\log_2N)$ 的。</p><h3 id="更新（-text-update-）"><a href="#更新（-text-update-）" class="headerlink" title="更新（$\text{update}$）"></a>更新（$\text{update}$）</h3><p>再来举个例子，更新 $[3, 8]$。</p><p>我们不断地下传给儿子，直到到了叶子节点之后，然后再向上更新。</p><p>这个思路应该很好理解，就是把所有点所在的叶子节点都改完后，再上传更新。</p><p>画图表示一下：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/j1ipwby8.png" alt=""></p><p>然后我们更新又分为三点：</p><ol><li>更新区间 $[x, y]$ 与这个节点管辖的区间 $[lt, rt]$ 没有关系。</li></ol><p>这里的图示与查询一样。</p><ol><li>更新区间 $[x, y]$ 与这个节点管辖的区间 $[lt, rt]$ 是完全包含且 $lt = rt$。</li></ol><p><del>这里作者不画，请自行脑补（bushi）。</del></p><p>其实就是到达了叶子节点。</p><ol><li>更新区间 $[x, y]$ 与这个节点管辖的区间 $[lt, rt]$ 是部分包含关系。或者是完全包含但是 $lt ≠ rt$。</li></ol><p>这里的图示也与查询一样。</p><p>然后只有当情况 $3$ 发生才传递给左右孩子。</p><p>$\text{update}$ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span> <span class="comment">//在 [x, y] 的区间元素均加 val</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; rt || y &lt; rt) <span class="comment">// 没有任何关系</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lt == rt &amp;&amp; x &lt;= lt &amp;&amp; rt &lt;= y) <span class="comment">//是叶子节点，且落在 [x, y] 内</span></span><br><span class="line">    &#123;</span><br><span class="line">        tree[cur] += val;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">update</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">    <span class="built_in">update</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">    <span class="built_in">pushup</span>(cur); <span class="comment">//cur 的左右孩子有可能修改了，那么 cur 管辖的区间和要更新</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的时间复杂度为 $O(4N)$。</p><h3 id="优化-1-（-text-lazy-tag-）"><a href="#优化-1-（-text-lazy-tag-）" class="headerlink" title="优化 $1$（$\text{lazy-tag}$）"></a>优化 $1$（$\text{lazy-tag}$）</h3><p>我们发现，虽然建树和查询的时间复杂度是<del>很低</del>的，但是更新的时间复杂度很高，连暴力都比不上。</p><p>我们思考更新的时间高的原因，是因为你把每个元素都给更新了，而如果后面又没有查询这段区间，那岂不是就亏了。</p><p>所以，总结一段话：<strong>修改是为询问而服务的。</strong></p><p>所以就诞生了 $\text{lazy-tag}$ 这个东西（没错，就是懒~标记）。</p><p>我们可以记录一个数组 $tag$，来记录每个节点的懒标记数值。所以，只要还没有查询到，这个懒标记就一直在睡觉~~（bushi）。</p><p>又来举上面那个例子，更新区间 $[3, 8]$，此时，我们发现节点 $5$ 和节点 $3$ 是被完全包含的，所以我们就把更新的值放在节点 $5$ 和节点 $3$ 上面，先把自己的值给加了（注意，一定要先把自己的值先加上），然后再把 $\text{lazy-tag}$ 加上要更新的值，等到以后有机会再还给儿子节点。</p><p>那么给出打懒标记的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span> <span class="comment">//cur，[lt, rt] 元素加 val</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tag[cur] += val;  <span class="comment">//加上以后要还给儿子们每个多少值</span></span><br><span class="line">    tree[cur] += (rt - lt + <span class="number">1</span>) * val;   <span class="comment">//这里要给自己加上</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后有人就问了，你这个懒标记总不能放在这里不动呀！那查询或更新的时候怎么办？没错，懒标记在这个时候的勤快了，在查询或更新的途中就顺便还“债”，把差的值还给儿子节点，同时又在儿子节点上打上标记，然后循环往复。</p><p>所以懒标记核心就一句话：只要你不查询，我就在这里睡觉，只要你一查询，我就托你顺便带给儿子节点。</p><p>然后给出下放标记（俗称托人带物，有个专业名词叫 $\text{pushdown}$）函数代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt)</span> <span class="comment">//lt, rt 表示 cur 节点所管辖的区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tag[cur] == <span class="number">0</span>) <span class="comment">//这里很重要，当没有标记，也就是为 0 时，就不要向下传了（有的题目不加会错）</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">addtag</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid, tag[cur]); <span class="comment">//给左右孩子打标记</span></span><br><span class="line">    <span class="built_in">addtag</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt, tag[cur]);</span><br><span class="line">    tag[cur] = <span class="number">0</span>;   <span class="comment">//最后还掉一身的债</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的 $\text{query}$ 和 $\text{update}$ 都要改一下：</p><p>$\text{query}$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="comment">//cur 代表当前的节点，lt, rt 表示这个节点所管辖的区间，x, y 表示我要询问的区间</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; rt || y &lt; lt) <span class="comment">//都已经没有关系了，直接返回 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y) <span class="comment">//是 [x, y] 的一部分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree[cur];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(cur, lt, rt); <span class="comment">//在这里下放标记，位置一定不能错</span></span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;   <span class="comment">//向左右儿子请求答案</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid, x, y) + <span class="built_in">query</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$\text{update}$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span> <span class="comment">//在 [x, y] 的区间元素均加 val</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt; rt || y &lt; rt) <span class="comment">// 没有任何关系</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y) <span class="comment">//是被完全包含，打懒标记</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">addtag</span>(cur, lt, rt, val);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">pushdown</span>(cur, lt, rt);   <span class="comment">//只要向下递归就要 pushdown</span></span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">update</span>(cur &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">    <span class="built_in">update</span>((cur &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">    <span class="built_in">pushup</span>(cur); <span class="comment">//cur 的左右孩子有可能修改了，那么 cur 管辖的区间和要更新</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先为什么 $\text{query}$ 和 $\text{update}$ 的 $\text{pushdown}$ 要放在那个位置，因为无论你时询问还是更新，只要向下递归就会下传。</p><p>至于 $\text{update}$ 的，当然是要在完全包含时才能 $\text{addtag}$ 的啦！</p><p>使用 $\text{lazy-tag}$ 之后时间复杂度会降到 $O(\log_2N)$（原理和查询一样）。</p><h3 id="优化-2-（标记永久化）"><a href="#优化-2-（标记永久化）" class="headerlink" title="优化 $2$（标记永久化）"></a>优化 $2$（标记永久化）</h3><p>线段树最出名的就是 $\text{lazy-tag}$ 了，它的优秀时间复杂度和实用性可以应对大多数情况。</p><p>而标记永久化呢？就是应对那些小部分情况。比如主席树区间修改，树套树（这里指线段树相套）矩阵修改。</p><p>标记永久化和 $\text{lazy-tag}$ 的区别：</p><ol><li><p>拒绝下传标记。</p></li><li><p>不一定每个区间的 $tree$ 加上 $tag$ 都是相对正确的。</p></li></ol><p>那么我们如何不用标记下传呢？</p><ol><li>我们的标记的值要加上 $tag \times (rt - lt + 1)$，并且要上传标记所带来的值。</li></ol><p>所以我们的 $\text{pushup}$ 就要改造一番：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  tree[node] = tree[node &lt;&lt; <span class="number">1</span>] + tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + (rt - lt + <span class="number">1</span>) * tag[node];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是在左右儿子的基础上加上这个节点的标记所给它带来的影响。</p><p>那么我们的 $\text{update}$ 也要改造一番：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y &lt; lt || x &gt; rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    tag[node] += val;   <span class="comment">//标记 += val，并且拒绝下传，直接 return ;</span></span><br><span class="line">    tree[node] += (rt - lt + <span class="number">1</span>) * val;   <span class="comment">//这个节点要加上值</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">  <span class="built_in">pushup</span>(node, lt, rt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>对于查询，我们只需要在一路时来加上相应的区间长度乘上<strong>这个区间的</strong> $tag$ 就可以了，利用一顿数学乱搞，就可以证明这样是对的（建议自己手推）。最后就是注意由于完全包含的已经加了，所以就不用再加一遍了。</li></ol><p>这里可以自己动手画画图，就可以明白了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y &lt; lt || x &gt; rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[node];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">min</span>(rt, y) - <span class="built_in">max</span>(lt, x) + <span class="number">1</span>) * tag[node] + <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y) + <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记永久化其实在现实中用得不多，出题人也不会去出这些稀奇古怪得题目（<del>除非是出题人脑袋有病，诚心卡你</del>），所以这一章节也没有什么用啦！</p><h3 id="最后的最后（空间提醒-amp-时间复杂度说明）"><a href="#最后的最后（空间提醒-amp-时间复杂度说明）" class="headerlink" title="最后的最后（空间提醒 &amp; 时间复杂度说明）"></a>最后的最后（空间提醒 &amp; 时间复杂度说明）</h3><p>这里先说一下，$tree$ 和 $tag$ 都要开 $4N$ 这么大。</p><p>证明：</p><p>一棵完全二叉树的节点数量为 $2N - 1$（这个可以自己 baidu），又因为线段树可能不是完全二叉树，可能多出 $2N - 1$ 个叶子节点，所以一共就是 $4N - 2$，差不多就是 $4N$。</p><p>所以最初的建树与更新都是 $O(4N)$ 的复杂度。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>这里给出 线段树 $1$ 的所有代码（<del>相信没有人会看吧</del>）。</p><p>代码 $1$（$\text{lazy-tag}$）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long    <span class="comment">//只提醒这里，要开 long long</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N * <span class="number">4</span>], tag[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">  tree[node] = tree[node &lt;&lt; <span class="number">1</span>] + tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  tag[node] += val;</span><br><span class="line">  tree[node] += (rt - lt + <span class="number">1</span>) * val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!tag[node])&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">addtag</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, tag[node]);</span><br><span class="line">  <span class="built_in">addtag</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, tag[node]);</span><br><span class="line">  tag[node] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">    tree[node] = a[lt];</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">  <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; rt || y &lt; lt)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    <span class="built_in">addtag</span>(node, lt, rt, val);</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(node, lt, rt);</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">  <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(x &gt; rt || y &lt; lt)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[node];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushdown</span>(node, lt, rt);</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y) + <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">int</span> x, y, k;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">int</span> x, y;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码 $2$（标记永久化）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tree[N * <span class="number">4</span>], tag[N * <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  tree[node] = tree[node &lt;&lt; <span class="number">1</span>] + tree[node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>] + (rt - lt + <span class="number">1</span>) * tag[node];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">    tree[node] = a[lt];</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">  <span class="built_in">pushup</span>(node, lt, rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y &lt; lt || x &gt; rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    tag[node] += val;</span><br><span class="line">    tree[node] += (rt - lt + <span class="number">1</span>) * val;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y, val);</span><br><span class="line">  <span class="built_in">update</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y, val);</span><br><span class="line">  <span class="built_in">pushup</span>(node, lt, rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(y &lt; lt || x &gt; rt)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= lt &amp;&amp; rt &lt;= y)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[node];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="built_in">min</span>(rt, y) - <span class="built_in">max</span>(lt, x) + <span class="number">1</span>) * tag[node] + <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span>, lt, mid, x, y) + <span class="built_in">query</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    cin &gt;&gt; a[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> op;</span><br><span class="line">    cin &gt;&gt; op;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">int</span> x, y, k;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;</span><br><span class="line">      <span class="built_in">update</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">int</span> x, y;</span><br><span class="line">      cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">      cout &lt;&lt; <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">1</span>, n, x, y) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>应该讲得很清楚（过于自信）。</del></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>使用线段树还可以解决区间最大值，最小值，最大公约数等问题。使用线段树解决的问题必须满足<strong>区间加法</strong>（这是重点）。</p><p>所谓区间加法。设 $[l, r]$，并且 $mid$ 是中点（$l + r &gt;&gt; 1$），打个比方：</p><p>$[l, mid]$ 的和 $+$ $[mid + 1, r]$ 的和等于 $[l, r]$ 的和。</p><p>区间加法就是这个意思。</p><h2 id="可持久化线段树-主席树"><a href="#可持久化线段树-主席树" class="headerlink" title="可持久化线段树/主席树"></a>可持久化线段树/主席树</h2><p><del>听说主席树这个名字是 OIer 们在谈论政治的时候发明了这个玩意。</del></p><h2 id="可持久化线段树有什么用"><a href="#可持久化线段树有什么用" class="headerlink" title="可持久化线段树有什么用"></a>可持久化线段树有什么用</h2><p>可持久化线段树可以保存每一个历史版本的线段树，使得可以在每一个历史版本上做查询和修改。</p><p>简单来说，就是可以后悔。</p><h2 id="可持久化线段树的思想"><a href="#可持久化线段树的思想" class="headerlink" title="可持久化线段树的思想"></a>可持久化线段树的思想</h2><p>我们还是通过一个例题来了解它：P3919。</p><p>我们可以发现什么？</p><p>我们可以发现这些东西：</p><ol><li><p>每次只有<strong>单点赋值</strong>。</p></li><li><p>每次只有单点查询。</p></li><li><p>涉及到每个历史版本的保存。</p></li></ol><p>那么，如何保存每个历史版本呢？</p><p>如果针对每一次操作开一棵线段树的话，空间会炸！</p><p>那么我们想，由于整棵树是一棵二叉树，所以高度为 $\log_2N$ 左右，所以我们每次单点赋值只会更改最多 $\log_2N$ 左右的线段树节点！这句话就是主席树的关键。</p><p>所以针对每一次操作，我们只需保存新的被修改过的线段树节点就行了。</p><p>那么我们如何建这棵线段树呢？请看以下这个图：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o6mkrwr3.png" alt=""></p><p>我们可以看出，更新操作在原始版本上是不做任何修改的。我们只需要新建要修改的节点的副本，并且把副本的值一一改变，再与原始版本连边就可以了。</p><p>新建副本的意思就是，新建修改过后的节点，然后连边到要修改的历史版本的线段树里的没有修改过的节点（自己看图就清晰了）。</p><p>那么我们需要注意什么：</p><ol><li><p>主席树里有很多个版本，因此就会有很多的根节点，我们可以用数组 $root$ 来保存每个版本的根节点。</p></li><li><p>每个节点有很多个父亲，但是永远只有<strong>两个儿子</strong>。</p></li><li><p>由于编号的问题，所以我们必须要记录节点个数以此来进行编号。</p></li><li><p>注意主席树里新建的点的左右儿子。</p></li><li><p>由于是单点修改，所以不需要懒标记。</p></li><li><p>在新建节点时，我们只需要把左右儿子分辨清楚就行了。</p></li></ol><p>现在我们发现从任何一个根节点向下递归都是一棵线段树。</p><p>所以按照这个思路就可以开始打代码了。</p><p>这里我是把初始看成版本 $1$。</p><p>这里因为 $\text{pushup}$ 还是一样的操作，所以我就没有放上来了。</p><h3 id="建树（-text-build-）-1"><a href="#建树（-text-build-）-1" class="headerlink" title="建树（$\text{build}$）"></a>建树（$\text{build}$）</h3><p>我们建树的时候可以先定义结构体 $segment_tree$：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;     <span class="comment">//代表左右孩子</span></span><br><span class="line">    <span class="type">int</span> lt, rt;    <span class="comment">//代表所表示的区间</span></span><br><span class="line">    <span class="type">int</span> val;      <span class="comment">//代表节点的值</span></span><br><span class="line">&#125;tree[N * <span class="number">4</span>];</span><br></pre></td></tr></table></figure><p>然后跟普通线段树一样的操作，只不过把 $root_1 = 1$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">      tree[node].lt = lt, tree[node].rt = rt;</span><br><span class="line">      tree[node].v = a[lt];   <span class="comment">//这里由于是叶子节点所以左右儿子不用记</span></span><br><span class="line">      <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tot = <span class="built_in">max</span>(tot, node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);   <span class="comment">//这里的 tot 表示的是节点总个数</span></span><br><span class="line">    tree[node].lt = lt, tree[node].rt = rt;</span><br><span class="line">    tree[node].l = node &lt;&lt; <span class="number">1</span>, tree[node].r = node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;    <span class="comment">//记录一下信息</span></span><br><span class="line">    <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">    <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">    <span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很简单。</p><h3 id="更新（-text-update-）-1"><a href="#更新（-text-update-）-1" class="headerlink" title="更新（$\text{update}$）"></a>更新（$\text{update}$）</h3><p>这里的更新先把代码放上来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[node].l &amp;&amp; !tree[node].r)&#123;</span><br><span class="line">        tot++;</span><br><span class="line">        tree[tot].lt = tree[node].lt, tree[tot].rt = tree[node].rt;</span><br><span class="line">        tree[tot].v = k;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    tot++;</span><br><span class="line">    tree[tot].lt = tree[node].lt, tree[tot].rt = tree[node].rt;</span><br><span class="line">    <span class="type">int</span> tmp = tot;</span><br><span class="line">    <span class="type">int</span> mid = tree[node].lt + tree[node].rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">        tree[tot].l = tot + <span class="number">1</span>, tree[tot].r = tree[node].r;</span><br><span class="line">        <span class="built_in">update</span>(tree[node].l, x, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        tree[tot].l = tree[node].l, tree[tot].r = tot + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">update</span>(tree[node].r, x, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后解释是什么意思。</p><p>首先我们看 $8$ ~ $10$ 行，这里是新建一个节点。注意第 $10$ 行，我们先记一下 $tot$，为准备 $\text{pushup}$。</p><p>我们再看 $12$ ~ $15$ 行，这里的意思是 $x$ 在左儿子的区间内，所以结合图例我们可以看出：</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z1qzcv8o.png" alt=""></p><p>我们发现，如果是这个节点的左节点要做修改，那么这个节点对应的新建的节点的左儿子就是接下来要新建的这个节点的左儿子节点的对应节点，我们可以算出编号为 $tot + 1$，然后新建节点的右孩子还是对应节点的右孩子。</p><p>然后如果是修改右孩子直接反过来即可。</p><p>再来看 $2$ ~ $7$ 行，这里是到了叶子节点，我们还是新建一个节点，然后将权值设为 $k$。记得要 <code>return ;</code></p><p><del>是不是很难？</del></p><h3 id="查询（-text-query-）-1"><a href="#查询（-text-query-）-1" class="headerlink" title="查询（$\text{query}$）"></a>查询（$\text{query}$）</h3><p>查询的话，直接向下搜，搜到叶子节点直接返回就行了：</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!tree[node].l &amp;&amp; !tree[node].r)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[node].v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = tree[node].lt + tree[node].rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tree[node].l, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tree[node].r, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个很简单吧！注意只要从要求搜的 $root$ 就行了。</p><h3 id="最后（空间复杂度分析）"><a href="#最后（空间复杂度分析）" class="headerlink" title="最后（空间复杂度分析）"></a>最后（空间复杂度分析）</h3><p>注意，这里由于每次操作只更改 $\log_2N$ 个节点，所以只需要 $O(M \log_2N)$ 的空间就可以把所有历史版本的线段树全部记下来。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>代码就放上来吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;    <span class="comment">//注意这里时间会超，要开快读</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, f = <span class="number">1</span>;</span><br><span class="line">  <span class="type">char</span> ch = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">      f = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">while</span>(ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">    x = x * <span class="number">10</span> + ch - <span class="number">48</span>;</span><br><span class="line">    ch = <span class="built_in">getchar</span>();</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> x * f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = N * <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> tot;     <span class="comment">//节点个数</span></span><br><span class="line"><span class="type">int</span> len, root[M];  <span class="comment">//所有版本的根节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment_tree</span>&#123;</span><br><span class="line">  <span class="type">int</span> lt, rt;    <span class="comment">//代表区间</span></span><br><span class="line">  <span class="type">int</span> l, r;   <span class="comment">//左右孩子</span></span><br><span class="line">  <span class="type">int</span> v;    <span class="comment">//代表值</span></span><br><span class="line">&#125;tree[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">  tree[node].v = tree[tree[node].l].v + tree[tree[node].r].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> lt, <span class="type">int</span> rt)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(lt == rt)&#123;</span><br><span class="line">    tree[node].lt = lt, tree[node].rt = rt;</span><br><span class="line">    tree[node].v = a[lt];</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = lt + rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  tot = <span class="built_in">max</span>(tot, node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>);</span><br><span class="line">  tree[node].lt = lt, tree[node].rt = rt;</span><br><span class="line">  tree[node].l = node &lt;&lt; <span class="number">1</span>, tree[node].r = node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span>, lt, mid);</span><br><span class="line">  <span class="built_in">build</span>(node &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, rt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!tree[node].l &amp;&amp; !tree[node].r)&#123;</span><br><span class="line">    tot++;</span><br><span class="line">    tree[tot].lt = tree[node].lt, tree[tot].rt = tree[node].rt;</span><br><span class="line">    tree[tot].v = k;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">  tot++;</span><br><span class="line">  tree[tot].lt = tree[node].lt, tree[tot].rt = tree[node].rt;</span><br><span class="line">  <span class="type">int</span> tmp = tot;</span><br><span class="line">  <span class="type">int</span> mid = tree[node].lt + tree[node].rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">    tree[tot].l = tot + <span class="number">1</span>, tree[tot].r = tree[node].r;</span><br><span class="line">    <span class="built_in">update</span>(tree[node].l, x, k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    tree[tot].l = tree[node].l, tree[tot].r = tot + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">update</span>(tree[node].r, x, k);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">pushup</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!tree[node].l &amp;&amp; !tree[node].r)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree[node].v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> mid = tree[node].lt + tree[node].rt &gt;&gt; <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(x &lt;= mid)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tree[node].l, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">query</span>(tree[node].r, x);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">  n = <span class="built_in">read</span>(), m = <span class="built_in">read</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">    a[i] = <span class="built_in">read</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  root[++len] = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">  <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">    <span class="type">int</span> v, op;</span><br><span class="line">    v = <span class="built_in">read</span>(), op = <span class="built_in">read</span>();</span><br><span class="line">    v++;</span><br><span class="line">    <span class="keyword">if</span>(op == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="type">int</span> x, k;</span><br><span class="line">      x = <span class="built_in">read</span>(), k = <span class="built_in">read</span>();</span><br><span class="line">      root[++len] = tot + <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">update</span>(root[v], x, k);    <span class="comment">//注意从哪个版本开始找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="type">int</span> x;</span><br><span class="line">      x = <span class="built_in">read</span>();</span><br><span class="line">      len++;</span><br><span class="line">      root[len] = root[v];   <span class="comment">//这里记一下版本根节点</span></span><br><span class="line">      cout &lt;&lt; <span class="built_in">query</span>(root[v], x) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">//这里也一样</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">Solve</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="疑问-amp-催更"><a href="#疑问-amp-催更" class="headerlink" title="疑问 &amp; 催更"></a>疑问 &amp; 催更</h2><p>请私信 $\color{red}\text{_Alexande_}$，这里有快速链接：<a href="https://www.luogu.com.cn/chat?uid=363006">$\text{Link}$</a>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
